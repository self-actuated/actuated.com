<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" content="#000000"/><meta name="author" content="OpenFaaS Ltd"/><meta name="twitter:card" content="summary_large_image"/><title>How Calyptia fixed its Arm builds whilst saving money</title><meta name="description" content="Learn how Calyptia fixed its failing Arm builds for open-source Fluent Bit and accelerated our commercial development by adopting Actuated and bare-metal runners."/><meta property="twitter:title" content="How Calyptia fixed its Arm builds whilst saving money"/><meta property="twitter:description" content="Learn how Calyptia fixed its failing Arm builds for open-source Fluent Bit and accelerated our commercial development by adopting Actuated and bare-metal runners."/><meta property="og:title" content="How Calyptia fixed its Arm builds whilst saving money"/><meta property="og:description" content="Learn how Calyptia fixed its failing Arm builds for open-source Fluent Bit and accelerated our commercial development by adopting Actuated and bare-metal runners."/><meta name="twitter:image:src" content="https://actuated.dev/images/2023-08-calyptia-casestudy/background.png"/><meta property="og:image" content="https://actuated.dev/images/2023-08-calyptia-casestudy/background.png"/><meta name="next-head-count" content="13"/><meta charSet="utf-8"/><link rel="icon" type="image/png" href="/images/actuated.png"/><link rel="stylesheet" href="https://rsms.me/inter/inter.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css"/><link rel="manifest" href="/manifest.json"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M5YNDNX7VT"></script><script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-M5YNDNX7VT');
          </script><link rel="apple-touch-icon" href="/images/actuated.png"/><link rel="preload" href="/_next/static/css/835182c647a0329c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/835182c647a0329c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-34e2100d07ae5757.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ba4f0f0b110ca3d9.js" defer=""></script><script src="/_next/static/chunks/552-542f150c917a7625.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-109b0d2eddac75b5.js" defer=""></script><script src="/_next/static/OapJj01SDiaAYxJr3VT0f/_buildManifest.js" defer=""></script><script src="/_next/static/OapJj01SDiaAYxJr3VT0f/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-white"><header><div class="relative bg-white" data-headlessui-state=""><div class="mx-auto flex max-w-7xl items-center justify-between px-4 py-6 sm:px-6 md:justify-start md:space-x-10 lg:px-8"><div class="flex justify-start lg:w-0 lg:flex-1"><a href="/"><span class="sr-only">Actuated</span><img class="h-8 w-auto sm:h-10" src="/images/actuated.png" alt="Actuated logo"/></a></div><div class="-my-2 -mr-2 md:hidden"><button class="inline-flex items-center justify-center rounded-md bg-white p-2 text-gray-400 hover:bg-gray-100 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><nav class="hidden space-x-10 md:flex"><div class="relative" data-headlessui-state=""><button class="text-gray-500 group inline-flex items-center rounded-md bg-white text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" type="button" aria-expanded="false" data-headlessui-state=""><span>Solutions</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="/blog">Blog</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="https://actuated.dev/blog/blazing-fast-ci-with-microvms">Announcement</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="/pricing">Pricing</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="https://docs.actuated.dev/">Docs</a></nav><div class="hidden items-center justify-end md:flex md:flex-1 lg:w-0"><a href="https://dashboard.actuated.dev" class="whitespace-nowrap text-base font-medium text-gray-500 hover:text-gray-900">Sign in</a><a href="/pricing" class="ml-8 inline-flex items-center justify-center whitespace-nowrap rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-indigo-700">Sign-up</a></div></div></div></header><main><div class="container mx-auto max-w-4xl bg-white mt-4 px-4 sm:px-6"><h1 id="post_title" class="text-3xl mb-3 leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl sm:leading-10 text-center">How Calyptia fixed its Arm builds whilst saving money</h1></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-4xl"><div class="border-b border-gray-200 py-4 flex items-center text-gray-500 mx-auto"><div><img class="h-10 w-10 rounded-full" src="/images/patrick-stephens.jpg" alt=""/></div><div class="ml-3"><p id="post_author" class="text-sm leading-5 font-medium text-gray-900"></p><div class="flex text-sm leading-5 text-gray-500"><time dateTime="2023-08-11" id="post_date">August 11, 2023</time><span class="mx-1"></span></div></div></div><div class="mt-6 prose sm:prose-lg max-w-none"><p id="post_description" class="mb-4">Learn how Calyptia fixed its failing Arm builds for open-source Fluent Bit and accelerated our commercial development by adopting Actuated and bare-metal runners.</p></div><div id="post_content" class="mt-6 prose sm:prose-lg max-w-none"><p>This is a case-study, and guest article by <a href="https://www.linkedin.com/in/patrickjkstephens/">Patrick Stephens, Tech Lead of Infrastructure at Calyptia</a>.</p>
<h2>Introduction</h2>
<p>Different architecture builds can be slow using the Github Actions hosted runners due to emulation of the non-native architecture for the build. This blog shows a simple way to make use of self-hosted runners for dedicated builds but in a secure and easy to maintain fashion.</p>
<p><a href="https://calyptia.io">Calyptia</a> maintains the OSS and <a href="https://cncf.io">Cloud Native Computing Foundation (CNCF)</a> graduated Fluent projects including <a href="https://docs.fluentbit.io">Fluent Bit</a>. We then add value to the open-source core by providing commercial services and enterprise-level features.</p>
<blockquote>
<p>Fluent Bit is a Fast and Lightweight Telemetry Agent for Logs, Metrics, and Traces for Linux, macOS, Windows, and BSD family operating systems. It has been made with a strong focus on performance to allow the collection and processing of telemetry data from different sources without complexity.</p>
<p>It was originally created by <a href="https://twitter.com/edsiper">Eduardo Silva</a> and is now an independent project.</p>
</blockquote>
<p>To learn about Fluent Bit, the Open Source telemetry agent that Calyptia maintains, <a href="https://docs.fluentbit.io/manual/about/what-is-fluent-bit">check out their docs</a>.</p>
<h3>The Problem</h3>
<p>One of the best things about Fluent Bit is that we provide native packages (RPMs and DEBs) for a myriad of supported targets (various Linux, macOS and Windows), however to do this is also one of the hardest things to support due to the complexity of building and testing across all these targets.</p>
<p>When PRs are provided we would like to ensure they function across the targets but doing so can take a very long time (hours) and consume a lot of resources (that must be paid for). This means that these long running jobs are only done via exception (manually labelling a PR or on full builds for releases) leading to issues only discovered when a full build &#x26; test is done, e.g. during the release process so blocking the release until it is fixed.</p>
<p>The long build time problem came to a head when we discovered we could no longer build for Amazon Linux 2023 (AL2023) because the build time exceeded the 6 hour limit for a single job on Github. We had to disable the AL2023 target for releases which means users cannot then update to the latest release leading to missing features or security problems: <a href="https://github.com/fluent/fluent-bit/issues/6978">See the issue here</a></p>
<p>In addition to challenges in the OSS, there are also challenges on the commercial side. Here, we are seeing issues with extended build times for ARM64 targets because our CI is based on Github Actions and currently only AMD64 (also called x86-64 or x64) runners are provided for builds. This slows down development and can mean bugs are not caught as early as possible.</p>
<h3>Why not use self-hosted runners?</h3>
<p>One way to speed up builds is to provide self-hosted ARM64 runners.</p>
<p>Unfortunately, runners pose security implications, particularly for public repositories. In fact, Github recommends against using self-hosted runners: About self-hosted runners - GitHub Docs</p>
<p>In addition to security concerns, there are also infrastructure implications for using self-hosted runners. We have to provide the infrastructure around deploying and managing the self-hosted runners, installing an agent, configuring it for jobs, etc. From a perspective of OSS we want anything we do to be simple and easy for maintenance purposes.</p>
<p>Any change we make needs to be compatible with downstream forks as well. We do not want to break builds for existing users, particularly for those who are contributors as well to the open source project. Therefore we need a solution that does not impact them.</p>
<p>There are various tools that can help with managing self-hosted runners, <a href="https://jonico.github.io/awesome-runners/">https://jonico.github.io/awesome-runners/</a> provides a good curated list. I performed an evaluation of some of the recommended tools but the solution would be non-trivial and require some effort to maintain.</p>
<h3>Our considerations</h3>
<p>We have the following high level goals in a rough priority order:</p>
<ul>
<li>Speed up the build.</li>
<li>Keep costs minimal.</li>
<li>Keep the process as secure as possible.</li>
<li>Make it simple to deploy and manage.</li>
<li>Minimise impact to OSS forks and users.</li>
</ul>
<h3>The solution</h3>
<p>At Kubecon EU 2023 I met up with Alex Ellis from Actuated (and of <a href="https://openfaas.com/">OpenFaaS</a> fame) in-person and we wanted to put Alex and his technology to the test, to see if the Actuated technology could fix the problems we see with our build process.</p>
<p>To understand what Actuated is then it is best to refer to their documentation with this specific blog post being a good overview of why we considered adopting it. We're not the only CNCF project that Alex's team was able to help. He describes how he helped Parca and Network Service Mesh to slash their build teams by using native Arm hardware.</p>
<p>A quick TLDR; though would be that Actuated provides an agent you install which then automatically creates ephemeral VMs on the host for each build job. Actuated seemed to tick the various boxes (see the considerations above) we had for it but never trust a vendor until you’ve tried it yourself!</p>
<p>Quote from Alex:</p>
<blockquote>
<p>"Actuated aims to give teams the closest possible experience to managed runners, but with native arm support flat rate billing, and secure VM-level isolation. Since Calyptia adopted actuated, we’ve also shipped an SSH debug experience (like you’d find with CircleCI) and detailed reports and insights on usage across repos, users and organisations."</p>
</blockquote>
<p>To use Actuated, you have to provision a machine with the Actuated agent, which is trivial and well documented: <a href="https://docs.actuated.dev/install-agent/">https://docs.actuated.dev/install-agent/</a>.</p>
<p>We deployed an Ampere Altra Q80 server with 256GB of RAM and 80 cores ARM64 machine via Equinix (Equinix donates resources to the CNCF which we use for Fluent Bit so this satisfies the cost side of things) and installed the Actuated agent on it per the Actuated docs.</p>
<p>The update required to start using Actuated in OSS Fluent Bit is a one-liner. (Thanks in part to my excellent work refactoring the CI workflows, or so I like to think. You can see the actual PR here for the change: <a href="https://github.com/fluent/fluent-bit/pull/7527">https://github.com/fluent/fluent-bit/pull/7527</a>.)</p>
<p>The following is the code required to start using Actuated:</p>
<pre><code class="hljs language-diff"><span class="hljs-deletion">-    runs-on: ubuntu-latest</span>
<span class="hljs-addition">+    runs-on: ${{ (contains(matrix.distro, 'arm' ) &#x26; 'actuated-arm64') || 'ubuntu-latest' }}</span>
</code></pre>
<p>For most people, the change will be much simpler:</p>
<pre><code class="hljs language-diff"><span class="hljs-deletion">-    runs-on: ubuntu-latest</span>
<span class="hljs-addition">+    runs-on: actuated</span>
</code></pre>
<p>In Github Actions parlance, the code above translates to “if we are doing an ARM build, then use the Actuated runner; otherwise, use the default Github Hosted (AMD64) Ubuntu runner”.</p>
<p>In the real code, I added an extra check so that we only use Actuated runners for the official source repo which means any forks will also carry on running as before on the Github Hosted runner.</p>
<p>With this very simple change, all the ARM64 builds that used to take hours to complete now finish in minutes. In addition, we can actually build the AL2023 ARM64 target to satisfy those users too. <strong>A simple change gave us a massive boost to performance and also provided a missing target.</strong></p>
<p>To demonstrate this is not specific to Equinix hosts or in some fashion difficult to manage in heterogeneous infrastructure (e.g. various hosts/VMs from different providers), we also replicated this for all our commercial offerings using a bare-metal Hetzner host. The process was identical: install the agent and make the runs-on code change as above to use Actuated. Massive improvements in build time were seen again as expected.</p>
<p>The usage of bare-metal (or cloud) hosts providers is invisible and only a choice of which provider you want to put the agent on. In our case we have a mixed set up with no difference in usage or maintenance.</p>
<h3>Challenges building containers</h3>
<p>The native package (RPM/DEB) building described above was quite simple to integrate via the existing workflows we had.</p>
<p>Building the native packages is done via a process that runs a target-specific container for each of the builds, e.g. we run a CentOS container to build for that target. This allows a complete build to be run on any Linux-compatible machine with a container runtime either in CI or locally. For ARM builds, we were using QEMU emulation for ARM builds hence the slowdown as this has to emulate instructions between architectures.</p>
<p>Container builds are the primary commercial area for improvement as we provide a SAAS solution running on K8S. Container builds were also a trickier proposition for OSS as we were using a single job to build all architectures using the docker/build-push-action. The builds were incredibly slow for ARM and also atomic, which means if you received a transient issue in one of the architecture builds, you would have to repeat the whole lot.</p>
<p>As an example: <a href="https://github.com/fluent/fluent-bit/blob/master/.github/workflows/call-build-images.yaml">https://github.com/fluent/fluent-bit/blob/master/.github/workflows/call-build-images.yaml</a></p>
<pre><code class="hljs language-yaml">      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">the</span> <span class="hljs-string">production</span> <span class="hljs-string">images</span>
        <span class="hljs-attr">id:</span> <span class="hljs-string">build_push</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">docker/build-push-action@v4</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">file:</span> <span class="hljs-string">./dockerfiles/Dockerfile</span>
          <span class="hljs-attr">context:</span> <span class="hljs-string">.</span>
          <span class="hljs-attr">tags:</span> <span class="hljs-string">${{</span> <span class="hljs-string">steps.meta.outputs.tags</span> <span class="hljs-string">}}</span>
          <span class="hljs-attr">labels:</span> <span class="hljs-string">${{</span> <span class="hljs-string">steps.meta.outputs.labels</span> <span class="hljs-string">}}</span>
          <span class="hljs-attr">platforms:</span> <span class="hljs-string">linux/amd64,</span> <span class="hljs-string">linux/arm64,</span> <span class="hljs-string">linux/arm/v7</span>
          <span class="hljs-attr">target:</span> <span class="hljs-string">production</span>
          <span class="hljs-comment"># Must be disabled to provide legacy format images from the registry</span>
          <span class="hljs-attr">provenance:</span> <span class="hljs-literal">false</span>
          <span class="hljs-attr">push:</span> <span class="hljs-literal">true</span>
          <span class="hljs-attr">load:</span> <span class="hljs-literal">false</span>
          <span class="hljs-attr">build-args:</span> <span class="hljs-string">|
            FLB_NIGHTLY_BUILD=${{ inputs.unstable }}
            RELEASE_VERSION=${{ inputs.version }}
</span></code></pre>
<p>The build step above is a bit more complex to tease out into separate components: we need to run single architecture builds for each target then provide a multi-arch manifest that links them together.</p>
<p>We reached out to Alex on a good way to modify this to work within a split build per architecture approach. The Actuated team has been very responsive on these types of questions along with proactive monitoring of our build queue and runners.</p>
<p>Within Calyptia we have followed the approach Docker provided here and suggested by the Actuated team: <a href="https://docs.docker.com/build/ci/github-actions/multi-platform/#distribute-build-across-multiple-runners">https://docs.docker.com/build/ci/github-actions/multi-platform/#distribute-build-across-multiple-runners</a></p>
<p>Based on what we learned, we recommend the following process is followed:</p>
<p>Build each architecture and push by digest in a set of parallel matrix jobs.
Capture the output digest of each build.
Create the multi-arch manifest made up of each digest we have pushed in step 1 using the artefact from step 2.</p>
<p>This approach provides two key benefits. First, it allows us to run on dedicated runners per-arch. Second, if a job fails we only need to repeat the single job, instead of having to rebuild all architectures.</p>
<p>The new approach reduced the time for the release process for the Calyptia Core K8S Operator from more than an hour to minutes. Additionally, because we can do this so quickly, we now build all architectures for every change rather than just on release. This helps developers who are running ARM locally for development as they have containers always available.</p>
<p>The example time speed up for the Calyptia Core K8S operator process was replicated across all the other components. A very good bang for your buck!</p>
<p>For us, the actuated subscription fee has been of great value. Initially we tested the waters on the Basic Plan, but soon upgraded when we saw more areas where we could use it. The cost for us has been offset against a massive improvement in CI time and development time plus reducing the infrastructure costs of managing the self-hosted runners.</p>
<h2>Lessons learned</h2>
<p>The package updates were seamless really, however we did encounter some issues with the ecosystem (not with actuated), when refactoring and updating our container builds. The issues with the container builds are covered below to help anyone else with the same problems.</p>
<h3>Provenance is now enabled by default</h3>
<p>We were using v3 of Docker’s docker/build-push-action, but they made a breaking change which caused us a headache. They changed the default in v4 to create the various extra artifacts for provenance (e.g. SBOMs) which did have a few extra side effects both at the time and even now.</p>
<p>If you do not disable this then it will push manifest lists rather than images so you will subsequently get an error message when you try to create a manifest list of another manifest list.</p>
<p>Separately this also causes issues for older docker clients or organisations that need the legacy Docker schema format from a registry: using it means only OCI format schemas are pushed. This impacted both OSS and our commercial offerings: <a href="https://github.com/fluent/fluent-bit/issues/7748">https://github.com/fluent/fluent-bit/issues/7748</a>.</p>
<p>It meant people on older OS’s or with requirements on only consuming Docker schema (e.g. maybe an internal mirror registry only supports that) could not pull the images.</p>
<h3>Invalid timestamps for gcr.io with manifests</h3>
<p>A funny problem found with our cloud-run deployments for Calyptia Core SAAS offering was that pushing the manifests to (Google Container Registry) gcr.io meant they ended up with a zero-epoch timestamp. This messed up some internal automation for us when we tried to get the latest version.</p>
<p>To resolve this we just switched back to doing a single architecture build as we do not need multi-arch manifests for cloud-run. Internally we still have multi-arch images in ghcr.io for internal use anyway, this is purely the promotion to gcr.io.</p>
<h3>Manifests cannot use sub-paths</h3>
<p>This was a fun one: when specifying images to make up your manifest they must be in the same registry of course!</p>
<p>Now, we tend to use sub-paths a lot to handle specific use cases for ghcr.io but unfortunately you cannot use them when trying to construct a manifest.</p>
<p>OK: ghcr.io/calyptia/internal/product:tag --> ghcr.io/calyptia/internal/product:tag-amd64
NOK: ghcr.io/calyptia/internal/product:tag --> ghcr.io/calyptia/internal/amd64/product:tag</p>
<p>As with all good failures, the tooling let me make a broken manifest at build time but unfortunately trying to pull it meant a failure at runtime.</p>
<h3>Actuated container registry mirror</h3>
<p>All Github hosted runners provide default credentials to authenticate with docker.io for pulling public images. When running on a self-hosted runner you need to authenticate for this otherwise you will hit rate limits and builds may fail as they cannot download required base images.</p>
<p>Actuated provide a registry mirror and Github Action to simplify this so make sure you set it up: <a href="https://docs.actuated.dev/tasks/registry-mirror/">https://docs.actuated.dev/tasks/registry-mirror/</a></p>
<p>As part of this, ensure it is set up for anything that uses images (e.g. we run integration tests on KIND that failed as the cluster could not download its images) and that it is done after any buildx config as it creates a dedicated buildx builder for the mirror usage.</p>
<h3>Actuated support</h3>
<p>The Actuated team helped us in two ways: the first was that we were able to enable Arm builds for our OSS projects and our commercial products, when they timed out with hosted runners. The second way was where our costs were getting out of hand on GitHub’s larger hosted runners: Actuated not only reduced the build time, but the billing model is flat-rate, meaning our costs are now fixed, rather than growing.</p>
<p>As we made suggestions or collaborated with the Actuated team, they updated the documentation, including our suggestions on smoothing out the onboarding of new build servers and new features for the CLI.</p>
<p>The more improvements we’ve made, the more we’ve seen. Next on our list is getting the runtime of a Go release down from 26 minutes by bringing it over to actuated.</p>
<h2>Conclusion</h2>
<p>Alex Ellis: We've learned a lot working with Patrick and Calyptia and are pleased to see that they were able to save money, whilst getting much quicker, and safer Open Source and commercial builds.</p>
<p>We value getting feedback and suggestions from customers, and Patrick continues to provide plenty of them.</p>
<p>If you'd like to learn more about actuated, reach out to speak to our team by clicking "Sign-up" and filling out the form. We'll be in touch to arrange a call.</p></div></div></main><footer class="bg-white"><div class="mx-auto max-w-7xl py-12 px-4 sm:px-6 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-400 hover:text-gray-500" href="https://twitter.com/selfactuated"><span class="sr-only">Twitter</span><svg fill="currentColor" viewBox="0 0 24 24" class="h-6 w-6" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg></a><a class="text-gray-400 hover:text-gray-500" href="https://github.com/self-actuated"><span class="sr-only">GitHub</span><svg fill="currentColor" viewBox="0 0 24 24" class="h-6 w-6" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"></path></svg></a><a class="text-gray-400 hover:text-gray-500" href="/rss.xml"><span class="sr-only">RSS</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-6 w-6" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M12.75 19.5v-.75a7.5 7.5 0 00-7.5-7.5H4.5m0-6.75h.75c7.87 0 14.25 6.38 14.25 14.25v.75M6 18.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0z"></path></svg></a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-base text-gray-400">© 2022 <a href="https://openfaas.com">OpenFaaS Ltd</a>, Inc. All rights reserved.</p></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"calyptia-case-study-arm","fileName":"2023-08-11-calyptia-case-study-arm.md","contentHtml":"\u003cp\u003eThis is a case-study, and guest article by \u003ca href=\"https://www.linkedin.com/in/patrickjkstephens/\"\u003ePatrick Stephens, Tech Lead of Infrastructure at Calyptia\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eDifferent architecture builds can be slow using the Github Actions hosted runners due to emulation of the non-native architecture for the build. This blog shows a simple way to make use of self-hosted runners for dedicated builds but in a secure and easy to maintain fashion.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://calyptia.io\"\u003eCalyptia\u003c/a\u003e maintains the OSS and \u003ca href=\"https://cncf.io\"\u003eCloud Native Computing Foundation (CNCF)\u003c/a\u003e graduated Fluent projects including \u003ca href=\"https://docs.fluentbit.io\"\u003eFluent Bit\u003c/a\u003e. We then add value to the open-source core by providing commercial services and enterprise-level features.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFluent Bit is a Fast and Lightweight Telemetry Agent for Logs, Metrics, and Traces for Linux, macOS, Windows, and BSD family operating systems. It has been made with a strong focus on performance to allow the collection and processing of telemetry data from different sources without complexity.\u003c/p\u003e\n\u003cp\u003eIt was originally created by \u003ca href=\"https://twitter.com/edsiper\"\u003eEduardo Silva\u003c/a\u003e and is now an independent project.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eTo learn about Fluent Bit, the Open Source telemetry agent that Calyptia maintains, \u003ca href=\"https://docs.fluentbit.io/manual/about/what-is-fluent-bit\"\u003echeck out their docs\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eThe Problem\u003c/h3\u003e\n\u003cp\u003eOne of the best things about Fluent Bit is that we provide native packages (RPMs and DEBs) for a myriad of supported targets (various Linux, macOS and Windows), however to do this is also one of the hardest things to support due to the complexity of building and testing across all these targets.\u003c/p\u003e\n\u003cp\u003eWhen PRs are provided we would like to ensure they function across the targets but doing so can take a very long time (hours) and consume a lot of resources (that must be paid for). This means that these long running jobs are only done via exception (manually labelling a PR or on full builds for releases) leading to issues only discovered when a full build \u0026#x26; test is done, e.g. during the release process so blocking the release until it is fixed.\u003c/p\u003e\n\u003cp\u003eThe long build time problem came to a head when we discovered we could no longer build for Amazon Linux 2023 (AL2023) because the build time exceeded the 6 hour limit for a single job on Github. We had to disable the AL2023 target for releases which means users cannot then update to the latest release leading to missing features or security problems: \u003ca href=\"https://github.com/fluent/fluent-bit/issues/6978\"\u003eSee the issue here\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIn addition to challenges in the OSS, there are also challenges on the commercial side. Here, we are seeing issues with extended build times for ARM64 targets because our CI is based on Github Actions and currently only AMD64 (also called x86-64 or x64) runners are provided for builds. This slows down development and can mean bugs are not caught as early as possible.\u003c/p\u003e\n\u003ch3\u003eWhy not use self-hosted runners?\u003c/h3\u003e\n\u003cp\u003eOne way to speed up builds is to provide self-hosted ARM64 runners.\u003c/p\u003e\n\u003cp\u003eUnfortunately, runners pose security implications, particularly for public repositories. In fact, Github recommends against using self-hosted runners: About self-hosted runners - GitHub Docs\u003c/p\u003e\n\u003cp\u003eIn addition to security concerns, there are also infrastructure implications for using self-hosted runners. We have to provide the infrastructure around deploying and managing the self-hosted runners, installing an agent, configuring it for jobs, etc. From a perspective of OSS we want anything we do to be simple and easy for maintenance purposes.\u003c/p\u003e\n\u003cp\u003eAny change we make needs to be compatible with downstream forks as well. We do not want to break builds for existing users, particularly for those who are contributors as well to the open source project. Therefore we need a solution that does not impact them.\u003c/p\u003e\n\u003cp\u003eThere are various tools that can help with managing self-hosted runners, \u003ca href=\"https://jonico.github.io/awesome-runners/\"\u003ehttps://jonico.github.io/awesome-runners/\u003c/a\u003e provides a good curated list. I performed an evaluation of some of the recommended tools but the solution would be non-trivial and require some effort to maintain.\u003c/p\u003e\n\u003ch3\u003eOur considerations\u003c/h3\u003e\n\u003cp\u003eWe have the following high level goals in a rough priority order:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSpeed up the build.\u003c/li\u003e\n\u003cli\u003eKeep costs minimal.\u003c/li\u003e\n\u003cli\u003eKeep the process as secure as possible.\u003c/li\u003e\n\u003cli\u003eMake it simple to deploy and manage.\u003c/li\u003e\n\u003cli\u003eMinimise impact to OSS forks and users.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eThe solution\u003c/h3\u003e\n\u003cp\u003eAt Kubecon EU 2023 I met up with Alex Ellis from Actuated (and of \u003ca href=\"https://openfaas.com/\"\u003eOpenFaaS\u003c/a\u003e fame) in-person and we wanted to put Alex and his technology to the test, to see if the Actuated technology could fix the problems we see with our build process.\u003c/p\u003e\n\u003cp\u003eTo understand what Actuated is then it is best to refer to their documentation with this specific blog post being a good overview of why we considered adopting it. We're not the only CNCF project that Alex's team was able to help. He describes how he helped Parca and Network Service Mesh to slash their build teams by using native Arm hardware.\u003c/p\u003e\n\u003cp\u003eA quick TLDR; though would be that Actuated provides an agent you install which then automatically creates ephemeral VMs on the host for each build job. Actuated seemed to tick the various boxes (see the considerations above) we had for it but never trust a vendor until you’ve tried it yourself!\u003c/p\u003e\n\u003cp\u003eQuote from Alex:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\"Actuated aims to give teams the closest possible experience to managed runners, but with native arm support flat rate billing, and secure VM-level isolation. Since Calyptia adopted actuated, we’ve also shipped an SSH debug experience (like you’d find with CircleCI) and detailed reports and insights on usage across repos, users and organisations.\"\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eTo use Actuated, you have to provision a machine with the Actuated agent, which is trivial and well documented: \u003ca href=\"https://docs.actuated.dev/install-agent/\"\u003ehttps://docs.actuated.dev/install-agent/\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWe deployed an Ampere Altra Q80 server with 256GB of RAM and 80 cores ARM64 machine via Equinix (Equinix donates resources to the CNCF which we use for Fluent Bit so this satisfies the cost side of things) and installed the Actuated agent on it per the Actuated docs.\u003c/p\u003e\n\u003cp\u003eThe update required to start using Actuated in OSS Fluent Bit is a one-liner. (Thanks in part to my excellent work refactoring the CI workflows, or so I like to think. You can see the actual PR here for the change: \u003ca href=\"https://github.com/fluent/fluent-bit/pull/7527\"\u003ehttps://github.com/fluent/fluent-bit/pull/7527\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eThe following is the code required to start using Actuated:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-diff\"\u003e\u003cspan class=\"hljs-deletion\"\u003e-    runs-on: ubuntu-latest\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+    runs-on: ${{ (contains(matrix.distro, 'arm' ) \u0026#x26; 'actuated-arm64') || 'ubuntu-latest' }}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor most people, the change will be much simpler:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-diff\"\u003e\u003cspan class=\"hljs-deletion\"\u003e-    runs-on: ubuntu-latest\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+    runs-on: actuated\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn Github Actions parlance, the code above translates to “if we are doing an ARM build, then use the Actuated runner; otherwise, use the default Github Hosted (AMD64) Ubuntu runner”.\u003c/p\u003e\n\u003cp\u003eIn the real code, I added an extra check so that we only use Actuated runners for the official source repo which means any forks will also carry on running as before on the Github Hosted runner.\u003c/p\u003e\n\u003cp\u003eWith this very simple change, all the ARM64 builds that used to take hours to complete now finish in minutes. In addition, we can actually build the AL2023 ARM64 target to satisfy those users too. \u003cstrong\u003eA simple change gave us a massive boost to performance and also provided a missing target.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo demonstrate this is not specific to Equinix hosts or in some fashion difficult to manage in heterogeneous infrastructure (e.g. various hosts/VMs from different providers), we also replicated this for all our commercial offerings using a bare-metal Hetzner host. The process was identical: install the agent and make the runs-on code change as above to use Actuated. Massive improvements in build time were seen again as expected.\u003c/p\u003e\n\u003cp\u003eThe usage of bare-metal (or cloud) hosts providers is invisible and only a choice of which provider you want to put the agent on. In our case we have a mixed set up with no difference in usage or maintenance.\u003c/p\u003e\n\u003ch3\u003eChallenges building containers\u003c/h3\u003e\n\u003cp\u003eThe native package (RPM/DEB) building described above was quite simple to integrate via the existing workflows we had.\u003c/p\u003e\n\u003cp\u003eBuilding the native packages is done via a process that runs a target-specific container for each of the builds, e.g. we run a CentOS container to build for that target. This allows a complete build to be run on any Linux-compatible machine with a container runtime either in CI or locally. For ARM builds, we were using QEMU emulation for ARM builds hence the slowdown as this has to emulate instructions between architectures.\u003c/p\u003e\n\u003cp\u003eContainer builds are the primary commercial area for improvement as we provide a SAAS solution running on K8S. Container builds were also a trickier proposition for OSS as we were using a single job to build all architectures using the docker/build-push-action. The builds were incredibly slow for ARM and also atomic, which means if you received a transient issue in one of the architecture builds, you would have to repeat the whole lot.\u003c/p\u003e\n\u003cp\u003eAs an example: \u003ca href=\"https://github.com/fluent/fluent-bit/blob/master/.github/workflows/call-build-images.yaml\"\u003ehttps://github.com/fluent/fluent-bit/blob/master/.github/workflows/call-build-images.yaml\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ethe\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eproduction\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eimages\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebuild_push\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edocker/build-push-action@v4\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ewith:\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003efile:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e./dockerfiles/Dockerfile\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003econtext:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e.\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003etags:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e${{\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esteps.meta.outputs.tags\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e}}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003elabels:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e${{\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esteps.meta.outputs.labels\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e}}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eplatforms:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elinux/amd64,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elinux/arm64,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elinux/arm/v7\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003etarget:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eproduction\u003c/span\u003e\n          \u003cspan class=\"hljs-comment\"\u003e# Must be disabled to provide legacy format images from the registry\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eprovenance:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003epush:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eload:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ebuild-args:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e|\n            FLB_NIGHTLY_BUILD=${{ inputs.unstable }}\n            RELEASE_VERSION=${{ inputs.version }}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe build step above is a bit more complex to tease out into separate components: we need to run single architecture builds for each target then provide a multi-arch manifest that links them together.\u003c/p\u003e\n\u003cp\u003eWe reached out to Alex on a good way to modify this to work within a split build per architecture approach. The Actuated team has been very responsive on these types of questions along with proactive monitoring of our build queue and runners.\u003c/p\u003e\n\u003cp\u003eWithin Calyptia we have followed the approach Docker provided here and suggested by the Actuated team: \u003ca href=\"https://docs.docker.com/build/ci/github-actions/multi-platform/#distribute-build-across-multiple-runners\"\u003ehttps://docs.docker.com/build/ci/github-actions/multi-platform/#distribute-build-across-multiple-runners\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBased on what we learned, we recommend the following process is followed:\u003c/p\u003e\n\u003cp\u003eBuild each architecture and push by digest in a set of parallel matrix jobs.\nCapture the output digest of each build.\nCreate the multi-arch manifest made up of each digest we have pushed in step 1 using the artefact from step 2.\u003c/p\u003e\n\u003cp\u003eThis approach provides two key benefits. First, it allows us to run on dedicated runners per-arch. Second, if a job fails we only need to repeat the single job, instead of having to rebuild all architectures.\u003c/p\u003e\n\u003cp\u003eThe new approach reduced the time for the release process for the Calyptia Core K8S Operator from more than an hour to minutes. Additionally, because we can do this so quickly, we now build all architectures for every change rather than just on release. This helps developers who are running ARM locally for development as they have containers always available.\u003c/p\u003e\n\u003cp\u003eThe example time speed up for the Calyptia Core K8S operator process was replicated across all the other components. A very good bang for your buck!\u003c/p\u003e\n\u003cp\u003eFor us, the actuated subscription fee has been of great value. Initially we tested the waters on the Basic Plan, but soon upgraded when we saw more areas where we could use it. The cost for us has been offset against a massive improvement in CI time and development time plus reducing the infrastructure costs of managing the self-hosted runners.\u003c/p\u003e\n\u003ch2\u003eLessons learned\u003c/h2\u003e\n\u003cp\u003eThe package updates were seamless really, however we did encounter some issues with the ecosystem (not with actuated), when refactoring and updating our container builds. The issues with the container builds are covered below to help anyone else with the same problems.\u003c/p\u003e\n\u003ch3\u003eProvenance is now enabled by default\u003c/h3\u003e\n\u003cp\u003eWe were using v3 of Docker’s docker/build-push-action, but they made a breaking change which caused us a headache. They changed the default in v4 to create the various extra artifacts for provenance (e.g. SBOMs) which did have a few extra side effects both at the time and even now.\u003c/p\u003e\n\u003cp\u003eIf you do not disable this then it will push manifest lists rather than images so you will subsequently get an error message when you try to create a manifest list of another manifest list.\u003c/p\u003e\n\u003cp\u003eSeparately this also causes issues for older docker clients or organisations that need the legacy Docker schema format from a registry: using it means only OCI format schemas are pushed. This impacted both OSS and our commercial offerings: \u003ca href=\"https://github.com/fluent/fluent-bit/issues/7748\"\u003ehttps://github.com/fluent/fluent-bit/issues/7748\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIt meant people on older OS’s or with requirements on only consuming Docker schema (e.g. maybe an internal mirror registry only supports that) could not pull the images.\u003c/p\u003e\n\u003ch3\u003eInvalid timestamps for gcr.io with manifests\u003c/h3\u003e\n\u003cp\u003eA funny problem found with our cloud-run deployments for Calyptia Core SAAS offering was that pushing the manifests to (Google Container Registry) gcr.io meant they ended up with a zero-epoch timestamp. This messed up some internal automation for us when we tried to get the latest version.\u003c/p\u003e\n\u003cp\u003eTo resolve this we just switched back to doing a single architecture build as we do not need multi-arch manifests for cloud-run. Internally we still have multi-arch images in ghcr.io for internal use anyway, this is purely the promotion to gcr.io.\u003c/p\u003e\n\u003ch3\u003eManifests cannot use sub-paths\u003c/h3\u003e\n\u003cp\u003eThis was a fun one: when specifying images to make up your manifest they must be in the same registry of course!\u003c/p\u003e\n\u003cp\u003eNow, we tend to use sub-paths a lot to handle specific use cases for ghcr.io but unfortunately you cannot use them when trying to construct a manifest.\u003c/p\u003e\n\u003cp\u003eOK: ghcr.io/calyptia/internal/product:tag --\u003e ghcr.io/calyptia/internal/product:tag-amd64\nNOK: ghcr.io/calyptia/internal/product:tag --\u003e ghcr.io/calyptia/internal/amd64/product:tag\u003c/p\u003e\n\u003cp\u003eAs with all good failures, the tooling let me make a broken manifest at build time but unfortunately trying to pull it meant a failure at runtime.\u003c/p\u003e\n\u003ch3\u003eActuated container registry mirror\u003c/h3\u003e\n\u003cp\u003eAll Github hosted runners provide default credentials to authenticate with docker.io for pulling public images. When running on a self-hosted runner you need to authenticate for this otherwise you will hit rate limits and builds may fail as they cannot download required base images.\u003c/p\u003e\n\u003cp\u003eActuated provide a registry mirror and Github Action to simplify this so make sure you set it up: \u003ca href=\"https://docs.actuated.dev/tasks/registry-mirror/\"\u003ehttps://docs.actuated.dev/tasks/registry-mirror/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAs part of this, ensure it is set up for anything that uses images (e.g. we run integration tests on KIND that failed as the cluster could not download its images) and that it is done after any buildx config as it creates a dedicated buildx builder for the mirror usage.\u003c/p\u003e\n\u003ch3\u003eActuated support\u003c/h3\u003e\n\u003cp\u003eThe Actuated team helped us in two ways: the first was that we were able to enable Arm builds for our OSS projects and our commercial products, when they timed out with hosted runners. The second way was where our costs were getting out of hand on GitHub’s larger hosted runners: Actuated not only reduced the build time, but the billing model is flat-rate, meaning our costs are now fixed, rather than growing.\u003c/p\u003e\n\u003cp\u003eAs we made suggestions or collaborated with the Actuated team, they updated the documentation, including our suggestions on smoothing out the onboarding of new build servers and new features for the CLI.\u003c/p\u003e\n\u003cp\u003eThe more improvements we’ve made, the more we’ve seen. Next on our list is getting the runtime of a Go release down from 26 minutes by bringing it over to actuated.\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eAlex Ellis: We've learned a lot working with Patrick and Calyptia and are pleased to see that they were able to save money, whilst getting much quicker, and safer Open Source and commercial builds.\u003c/p\u003e\n\u003cp\u003eWe value getting feedback and suggestions from customers, and Patrick continues to provide plenty of them.\u003c/p\u003e\n\u003cp\u003eIf you'd like to learn more about actuated, reach out to speak to our team by clicking \"Sign-up\" and filling out the form. We'll be in touch to arrange a call.\u003c/p\u003e","title":"How Calyptia fixed its Arm builds whilst saving money","description":"Learn how Calyptia fixed its failing Arm builds for open-source Fluent Bit and accelerated our commercial development by adopting Actuated and bare-metal runners.","tags":["images","packer","qemu","kvm"],"author_img":"patrick-stephens","image":"/images/2023-08-calyptia-casestudy/background.png","date":"2023-08-11"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"calyptia-case-study-arm"},"buildId":"OapJj01SDiaAYxJr3VT0f","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>