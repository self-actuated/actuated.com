<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" content="#000000"/><meta name="author" content="OpenFaaS Ltd"/><meta name="twitter:card" content="summary_large_image"/><title>How to make GitHub Actions 22x faster with bare-metal Arm</title><meta name="description" content="GitHub doesn&#x27;t provide hosted Arm runners, so how can you use native Arm runners safely &amp; securely?"/><meta property="twitter:title" content="How to make GitHub Actions 22x faster with bare-metal Arm"/><meta property="twitter:description" content="GitHub doesn&#x27;t provide hosted Arm runners, so how can you use native Arm runners safely &amp; securely?"/><meta property="og:title" content="How to make GitHub Actions 22x faster with bare-metal Arm"/><meta property="og:description" content="GitHub doesn&#x27;t provide hosted Arm runners, so how can you use native Arm runners safely &amp; securely?"/><meta name="twitter:image:src" content="https://actuated.dev/images/2023-native-arm64-for-oss/in-progress-dashboard.png"/><meta property="og:image" content="https://actuated.dev/images/2023-native-arm64-for-oss/in-progress-dashboard.png"/><meta name="next-head-count" content="13"/><meta charSet="utf-8"/><link rel="icon" type="image/png" href="/images/actuated.png"/><link rel="stylesheet" href="https://rsms.me/inter/inter.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css"/><link rel="manifest" href="/manifest.json"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M5YNDNX7VT"></script><script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-M5YNDNX7VT');
          </script><link rel="apple-touch-icon" href="/images/actuated.png"/><link rel="preload" href="/_next/static/css/15b65ea57c2b2cf2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15b65ea57c2b2cf2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-34e2100d07ae5757.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9eaa0e4bc2cfcc69.js" defer=""></script><script src="/_next/static/chunks/552-542f150c917a7625.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-109b0d2eddac75b5.js" defer=""></script><script src="/_next/static/gpxkhRF3sNinvQxss-7sT/_buildManifest.js" defer=""></script><script src="/_next/static/gpxkhRF3sNinvQxss-7sT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-white"><header><div class="relative bg-white" data-headlessui-state=""><div class="mx-auto flex max-w-7xl items-center justify-between px-4 py-6 sm:px-6 md:justify-start md:space-x-10 lg:px-8"><div class="flex justify-start lg:w-0 lg:flex-1"><a href="/"><span class="sr-only">Actuated</span><img class="h-8 w-auto sm:h-10" src="/images/actuated.png" alt="Actuated logo"/></a></div><div class="-my-2 -mr-2 md:hidden"><button class="inline-flex items-center justify-center rounded-md bg-white p-2 text-gray-400 hover:bg-gray-100 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><nav class="hidden space-x-10 md:flex"><div class="relative" data-headlessui-state=""><button class="text-gray-500 group inline-flex items-center rounded-md bg-white text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" type="button" aria-expanded="false" data-headlessui-state=""><span>Solutions</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="/blog">Blog</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="https://actuated.dev/blog/blazing-fast-ci-with-microvms">Announcement</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="https://docs.actuated.dev/">Docs</a></nav><div class="hidden items-center justify-end md:flex md:flex-1 lg:w-0"><a href="https://dashboard.actuated.dev" class="whitespace-nowrap text-base font-medium text-gray-500 hover:text-gray-900">Sign in</a><a href="https://docs.actuated.dev/register/" class="ml-8 inline-flex items-center justify-center whitespace-nowrap rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-indigo-700">Sign up</a></div></div></div></header><main><div class="container mx-auto max-w-4xl bg-white mt-4 px-4 sm:px-6"><h1 id="post_title" class="text-3xl mb-3 leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl sm:leading-10 text-center">How to make GitHub Actions 22x faster with bare-metal Arm</h1></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-4xl"><div class="border-b border-gray-200 py-4 flex items-center text-gray-500 mx-auto"><div><img class="h-10 w-10 rounded-full" src="/images/alex.jpg" alt=""/></div><div class="ml-3"><p id="post_author" class="text-sm leading-5 font-medium text-gray-900">Alex Ellis</p><div class="flex text-sm leading-5 text-gray-500"><time dateTime="2023-01-17" id="post_date">January 17, 2023</time><span class="mx-1"></span></div></div></div><div class="mt-6 prose sm:prose-lg max-w-none"><p id="post_description" class="mb-4">GitHub doesn&#x27;t provide hosted Arm runners, so how can you use native Arm runners safely &amp; securely?</p></div><div id="post_content" class="mt-6 prose sm:prose-lg max-w-none"><p>GitHub Actions is a modern, fast and efficient way to build and test software, with free runners available. We use the free runners for various open source projects and are generally very pleased with them, after all, who can argue with good enough and free? But one of the main caveats is that GitHub's hosted runners don't yet support the Arm architecture.</p>
<p>So many people turn to software-based emulation using <a href="https://www.qemu.org/">QEMU</a>. QEMU is tricky to set up, and requires specific code and tricks if you want to use software in a standard way, without modifying it. But QEMU is great when it runs with hardware acceleration. Unfortunately, the hosted runners on GitHub do not have KVM available, so builds tend to be incredibly slow, and I mean so slow that it's going to distract you and your team from your work.</p>
<p>This was even more evident when <a href="https://twitter.com/fredbrancz">Frederic Branczyk</a> tweeted about his experience with QEMU on <a href="https://github.com/features/actions">GitHub Actions</a> for his open source observability project named <a href="https://github.com/parca-dev/parca">Parca</a>.</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Does anyone have a <a href="https://twitter.com/github?ref_src=twsrc%5Etfw">@github</a> actions self-hosted runner manifest for me to throw at a <a href="https://twitter.com/kubernetesio?ref_src=twsrc%5Etfw">@kubernetesio</a> cluster? I&#39;m tired of waiting for emulated arm64 CI runs taking ages.</p>&mdash; Frederic ðŸ§Š Branczyk @brancz@hachyderm.io (@fredbrancz) <a href="https://twitter.com/fredbrancz/status/1582779459379204096?ref_src=twsrc%5Etfw">October 19, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>I checked out his build and expected "ages" to mean 3 minutes, in fact, it meant 33.5 minutes. I know because I forked his project and ran a test build.</p>
<p>After migrating it to actuated and one of our build agents, the time dropped to 1 minute and 26 seconds, a 22x improvement for zero effort.</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">This morning <a href="https://twitter.com/fredbrancz?ref_src=twsrc%5Etfw">@fredbrancz</a> said that his ARM64 build was taking 33 minutes using QEMU in a GitHub Action and a hosted runner.<br><br>I ran it on <a href="https://twitter.com/selfactuated?ref_src=twsrc%5Etfw">@selfactuated</a> using an ARM64 machine and a microVM.<br><br>That took the time down to 1m 26s!! About a 22x speed increase. <a href="https://t.co/zwF3j08vEV">https://t.co/zwF3j08vEV</a> <a href="https://t.co/ps21An7B9B">pic.twitter.com/ps21An7B9B</a></p>&mdash; Alex Ellis (@alexellisuk) <a href="https://twitter.com/alexellisuk/status/1583089248084729856?ref_src=twsrc%5Etfw">October 20, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>You can see the results here:</p>
<p><a href="https://twitter.com/alexellisuk/status/1583089248084729856/photo/1"><img src="https://pbs.twimg.com/media/FfhC5z1XkAAoYjn?format=jpg&#x26;name=large" alt="Results from the test, side-by-side"></a></p>
<p>As a general rule, the download speed is going to be roughly the same with a hosted runner, it may even be slightly faster due to the connection speed of Azure's network.</p>
<p>But the compilation times speak for themselves - in the Parca build, <code>go test</code> was being run with QEMU. Moving it to run on the ARM64 host directly, resulted in the marked increase in speed. In fact, the team had introduced lots of complicated code to try and set up a Docker container to use QEMU, all that could be stripped out, replacing it with a very standard looking test step:</p>
<pre><code class="hljs language-yaml">  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">the</span> <span class="hljs-string">go</span> <span class="hljs-string">tests</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">go</span> <span class="hljs-string">test</span> <span class="hljs-string">./...</span>
</code></pre>
<h2>Can't I just install the self-hosted runner on an Arm VM?</h2>
<p>There are relatively cheap Arm VMs available from Oracle OCI, Google and Azure based upon the Ampere Altra CPU. AWS have their own Arm VMs available in the Graviton line.</p>
<p>So why shouldn't you just go ahead and install the runner and add them to your repos?</p>
<p>The moment you do that you run into three issues:</p>
<ul>
<li>You now have to maintain the software packages installed on that machine</li>
<li>If you use KinD or Docker, you're going to run into conflicts between builds</li>
<li>Out of the box scheduling is poor - by default it only runs one build at a time there</li>
</ul>
<p>Chasing your tail with package updates, faulty builds due to caching and conflicts is not fun, you may feel like you're saving money, but you are paying with your time and if you have a team, you're paying with their time too.</p>
<p>Most importantly, GitHub say that it cannot be used safely with a public repository. There's no security isolation, and state can be left over from one build to the next, including harmful code left intentionally by bad actors, or accidentally from malware.</p>
<h2>So how do we get to a safer, more efficient Arm runner?</h2>
<p>The answer is to get us as close as possible to a hosted runner, but with the benefits of a self-hosted runner.</p>
<p>That's where actuated comes in.</p>
<p>We run a SaaS that manages bare-metal for you, and talks to GitHub upon your behalf to schedule jobs efficiently.</p>
<ul>
<li>No need to maintain software, we do that for you with an automated OS image</li>
<li>We use microVMs to isolate builds from each other</li>
<li>Every build is immutable and uses a clean environment</li>
<li>We can schedule multiple builds at once without side-effects</li>
</ul>
<p>microVMs on Arm require a bare-metal server, and we have tested all the options available to us. Note that the Arm VMs discussed above do not currently support KVM or nested virtualisation.</p>
<ul>
<li>a1.metal on AWS - 16 cores / 32GB RAM - 300 USD / mo</li>
<li>c3.large.arm64 from <a href="https://metal.equinix.com/product/servers/c3-large-arm64/">Equinix Metal</a> with 80 Cores and 256GB RAM - 2.5 USD / hr</li>
<li><a href="https://www.hetzner.com/dedicated-rootserver/matrix-rx">RX-Line</a> from <a href="https://hetzner.com">Hetzner</a> with 128GB / 256GB RAM, NVMe &#x26; 80 cores for approx 200-250 EUR / mo.</li>
<li><a href="https://amzn.to/3WiSDE7">Mac Mini M1</a> - 8 cores / 16GB RAM - tested with Asahi Linux - one-time payment of ~ 1500 USD</li>
</ul>
<p>If you're already an AWS customer, the a1.metal is a good place to start. If you need expert support, networking and a high speed uplink, you can't beat Equinix Metal (we have access to hardware there and can help you get started) - you can even pay per minute and provision machines via API. The Mac Mini &#x3C;1 has a really fast NVMe and we're running one of these with Asahi Linux for our own Kernel builds for actuated. The RX Line from Hetzner has serious power and is really quite affordable, but just be aware that you're limited to a 1Gbps connection, a setup fee and monthly commitment, unless you pay significantly more.</p>
<p>I even tried Frederic's Parca job <a href="https://twitter.com/alexellisuk/status/1585228202087415808?s=20&#x26;t=kW-cfn44pQTzUsRiMw32kQ">on my 8GB Raspberry Pi with a USB NVMe</a>. Why even bother, do I hear you say? Well for a one-time payment of 80 USD, it was 26m30s quicker than a hosted runner with QEMU!</p>
<p><a href="https://alexellisuk.medium.com/upgrade-your-raspberry-pi-4-with-a-nvme-boot-drive-d9ab4e8aa3c2">Learn how to connect an NVMe over USB-C to your Raspberry Pi 4</a></p>
<h2>What does an Arm job look like?</h2>
<p>Since I first started trying to build code for Arm in 2015, I noticed a group of people who had a passion for this efficient CPU and platform. They would show up on GitHub issue trackers, ready to send patches, get access to hardware and test out new features on Arm chips. It was a tough time, and we should all be grateful for their efforts which go largely unrecognised.</p>
<blockquote>
<p>If you're looking to make your <a href="https://twitter.com/alexellisuk">software compatible with Arm</a>, feel free to reach out to me via Twitter.</p>
</blockquote>
<p>In 2020 when Apple released their M1 chip, Arm went mainstream, and projects that had been putting off Arm support like KinD and Minikube, finally had that extra push to get it done.</p>
<p>I've had several calls with teams who use Docker on their M1/M2 Macs exclusively, meaning they build only Arm binaries and use only Arm images from the Docker Hub. Some of them even ship to project using Arm images, but I think we're still a little behind the curve there.</p>
<p>That means Kubernetes - KinD/Minikube/K3s and Docker - including Buildkit, compose etc, all work out of the box.</p>
<p>I'm going to use the arkade CLI to download KinD and kubectl, however you can absolutely find the download links and do all this manually. I don't recommend it!</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">e2e-kind-test</span>

<span class="hljs-attr">on:</span> <span class="hljs-string">push</span>
<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">start-kind:</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@master</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">fetch-depth:</span> <span class="hljs-number">1</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">get</span> <span class="hljs-string">arkade</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">alexellis/setup-arkade@v1</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">get</span> <span class="hljs-string">kubectl</span> <span class="hljs-string">and</span> <span class="hljs-string">kubectl</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">alexellis/arkade-get@master</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">kubectl:</span> <span class="hljs-string">latest</span>
          <span class="hljs-attr">kind:</span> <span class="hljs-string">latest</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">a</span> <span class="hljs-string">KinD</span> <span class="hljs-string">cluster</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|
          mkdir -p $HOME/.kube/
          kind create cluster --wait 300s
</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Wait</span> <span class="hljs-string">until</span> <span class="hljs-string">CoreDNS</span> <span class="hljs-string">is</span> <span class="hljs-string">ready</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|
          kubectl rollout status deploy/coredns -n kube-system --timeout=300s
</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Explore</span> <span class="hljs-string">nodes</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">kubectl</span> <span class="hljs-string">get</span> <span class="hljs-string">nodes</span> <span class="hljs-string">-o</span> <span class="hljs-string">wide</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Explore</span> <span class="hljs-string">pods</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">kubectl</span> <span class="hljs-string">get</span> <span class="hljs-string">pod</span> <span class="hljs-string">-A</span> <span class="hljs-string">-o</span> <span class="hljs-string">wide</span>
</code></pre>
<p>That's our <code>x86_64</code> build, or Intel/AMD build that will run on a hosted runner, but will be kind of slow.</p>
<p>Let's convert it to run on an actuated ARM64 runner:</p>
<pre><code class="hljs language-diff">jobs:
  start-kind:
<span class="hljs-deletion">-    runs-on: ubuntu-latest</span>
<span class="hljs-addition">+    runs-on: actuated-aarch64</span>
</code></pre>
<p>That's it, we've changed the runner type and we're ready to go.</p>
<p><img src="/images/2023-native-arm64-for-oss/in-progress-dashboard.png" alt="In progress build on the dashboard"></p>
<blockquote>
<p>An in progress build on the dashboard</p>
</blockquote>
<p>Behind the scenes, actuated, the SaaS schedules the build on a bare-metal ARM64 server, the boot up takes less than 1 second, and then the standard GitHub Actions Runner talks securely to GitHub to run the build. The build is isolated from other builds, and the runner is destroyed after the build is complete.</p>
<p><img src="/images/2023-native-arm64-for-oss/arm-kind.png" alt="Setting up an Arm KinD cluster took about 49s"></p>
<blockquote>
<p>Setting up an Arm KinD cluster took about 49s</p>
</blockquote>
<p>Setting up an Arm KinD cluster took about 49s, then it's over to you to test your Arm images, or binaries.</p>
<p>If I were setting up CI and needed to test software on both Arm and x86_64, then I'd probably create two separate builds, one for each architecture, with a <code>runs-on</code> label of <code>actuated</code> and <code>actuated-aarch64</code> respectively.</p>
<p>Do you need to test multiple versions of Kubernetes? Let's face it, it changes so often, that who doesn't need to do that. You can use the <code>matrix</code> feature to test multiple versions of Kubernetes on Arm and x86_64.</p>
<p>I show 5x clusters being launched in parallel in the video below:</p>
<p><a href="https://www.youtube.com/watch?v=2o28iUC-J1w">Demo - Actuated - secure, isolated CI for containers and Kubernetes</a></p>
<p>What about Docker?</p>
<p>Docker comes pre-installed in the actuated OS images, so you can simply use <code>docker build</code>, without any need to install extra tools like Buildx, or to have to worry about multi-arch Dockerfiles. Although these are always good to have, and are <a href="https://github.com/openfaas/golang-http-template/blob/master/template/golang-middleware/Dockerfile">available out of the box in OpenFaaS</a>, if you're curious what a multi-arch Dockerfile looks like.</p>
<h2>Wrapping up</h2>
<p>Building on bare-metal Arm hosts is more secure because side effects cannot be left over between builds, even if malware is installed by a bad actor. It's more efficient because you can run multiple builds at once, and you can use the latest software with our automated Operating System image. Enabling actuated on a build is as simple as changing the runner type.</p>
<p>And as you've seen from the example with the OSS Parca project, moving to a native Arm server can improve speed by 22x, shaving off a massive 34 minutes per build.</p>
<p>Who wouldn't want that?</p>
<p>Parca isn't a one-off, I was also told by <a href="https://twitter.com/cohix">Connor Hicks from Suborbital</a> that they have an Arm build that takes a good 45 minutes due to using QEMU.</p>
<p>Just a couple of days ago <a href="https://twitter.com/edwarnicke?lang=en">Ed Warnicke, Distinguished Engineer at Cisco</a> reached out to us to pilot actuated. Why?</p>
<p>Ed, who had <a href="https://networkservicemesh.io/">Network Service Mesh</a> in mind said:</p>
<blockquote>
<p>I'd kill for proper Arm support. I'd love to be able to build our many containers for Arm natively, and run our KIND based testing on Arm natively.
We want to build for Arm - Arm builds is what brought us to actuated</p>
</blockquote>
<p>So if that sounds like where you are, reach out to us and we'll get you set up.</p>
<ul>
<li><a href="https://docs.google.com/forms/d/e/1FAIpQLScA12IGyVFrZtSAp2Oj24OdaSMloqARSwoxx3AZbQbs0wpGww/viewform">Register to pilot actuated with us</a></li>
</ul>
<p>Additional links:</p>
<ul>
<li><a href="https://docs.actuated.dev/">Actuated docs</a></li>
<li><a href="https://docs.actuated.dev/faq">FAQ &#x26; comparison to other solutions</a></li>
<li><a href="https://twitter.com/selfactuated">Follow actuated on Twitter</a></li>
</ul></div></div></main><footer class="bg-white"><div class="mx-auto max-w-7xl py-12 px-4 sm:px-6 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-400 hover:text-gray-500" href="https://twitter.com/self-actuated"><span class="sr-only">Twitter</span><svg fill="currentColor" viewBox="0 0 24 24" class="h-6 w-6" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg></a><a class="text-gray-400 hover:text-gray-500" href="https://github.com/self-actuated"><span class="sr-only">GitHub</span><svg fill="currentColor" viewBox="0 0 24 24" class="h-6 w-6" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"></path></svg></a><a class="text-gray-400 hover:text-gray-500" href="/rss.xml"><span class="sr-only">RSS</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-6 w-6" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M12.75 19.5v-.75a7.5 7.5 0 00-7.5-7.5H4.5m0-6.75h.75c7.87 0 14.25 6.38 14.25 14.25v.75M6 18.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0z"></path></svg></a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-base text-gray-400">Â© 2022 <a href="https://openfaas.com">OpenFaaS Ltd</a>, Inc. All rights reserved.</p></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"native-arm64-for-github-actions","fileName":"2023-01-17-native-arm64-for-github-actions.md","contentHtml":"\u003cp\u003eGitHub Actions is a modern, fast and efficient way to build and test software, with free runners available. We use the free runners for various open source projects and are generally very pleased with them, after all, who can argue with good enough and free? But one of the main caveats is that GitHub's hosted runners don't yet support the Arm architecture.\u003c/p\u003e\n\u003cp\u003eSo many people turn to software-based emulation using \u003ca href=\"https://www.qemu.org/\"\u003eQEMU\u003c/a\u003e. QEMU is tricky to set up, and requires specific code and tricks if you want to use software in a standard way, without modifying it. But QEMU is great when it runs with hardware acceleration. Unfortunately, the hosted runners on GitHub do not have KVM available, so builds tend to be incredibly slow, and I mean so slow that it's going to distract you and your team from your work.\u003c/p\u003e\n\u003cp\u003eThis was even more evident when \u003ca href=\"https://twitter.com/fredbrancz\"\u003eFrederic Branczyk\u003c/a\u003e tweeted about his experience with QEMU on \u003ca href=\"https://github.com/features/actions\"\u003eGitHub Actions\u003c/a\u003e for his open source observability project named \u003ca href=\"https://github.com/parca-dev/parca\"\u003eParca\u003c/a\u003e.\u003c/p\u003e\n\u003cblockquote class=\"twitter-tweet\"\u003e\u003cp lang=\"en\" dir=\"ltr\"\u003eDoes anyone have a \u003ca href=\"https://twitter.com/github?ref_src=twsrc%5Etfw\"\u003e@github\u003c/a\u003e actions self-hosted runner manifest for me to throw at a \u003ca href=\"https://twitter.com/kubernetesio?ref_src=twsrc%5Etfw\"\u003e@kubernetesio\u003c/a\u003e cluster? I\u0026#39;m tired of waiting for emulated arm64 CI runs taking ages.\u003c/p\u003e\u0026mdash; Frederic ðŸ§Š Branczyk @brancz@hachyderm.io (@fredbrancz) \u003ca href=\"https://twitter.com/fredbrancz/status/1582779459379204096?ref_src=twsrc%5Etfw\"\u003eOctober 19, 2022\u003c/a\u003e\u003c/blockquote\u003e \u003cscript async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"\u003e\u003c/script\u003e\n\u003cp\u003eI checked out his build and expected \"ages\" to mean 3 minutes, in fact, it meant 33.5 minutes. I know because I forked his project and ran a test build.\u003c/p\u003e\n\u003cp\u003eAfter migrating it to actuated and one of our build agents, the time dropped to 1 minute and 26 seconds, a 22x improvement for zero effort.\u003c/p\u003e\n\u003cblockquote class=\"twitter-tweet\"\u003e\u003cp lang=\"en\" dir=\"ltr\"\u003eThis morning \u003ca href=\"https://twitter.com/fredbrancz?ref_src=twsrc%5Etfw\"\u003e@fredbrancz\u003c/a\u003e said that his ARM64 build was taking 33 minutes using QEMU in a GitHub Action and a hosted runner.\u003cbr\u003e\u003cbr\u003eI ran it on \u003ca href=\"https://twitter.com/selfactuated?ref_src=twsrc%5Etfw\"\u003e@selfactuated\u003c/a\u003e using an ARM64 machine and a microVM.\u003cbr\u003e\u003cbr\u003eThat took the time down to 1m 26s!! About a 22x speed increase. \u003ca href=\"https://t.co/zwF3j08vEV\"\u003ehttps://t.co/zwF3j08vEV\u003c/a\u003e \u003ca href=\"https://t.co/ps21An7B9B\"\u003epic.twitter.com/ps21An7B9B\u003c/a\u003e\u003c/p\u003e\u0026mdash; Alex Ellis (@alexellisuk) \u003ca href=\"https://twitter.com/alexellisuk/status/1583089248084729856?ref_src=twsrc%5Etfw\"\u003eOctober 20, 2022\u003c/a\u003e\u003c/blockquote\u003e \u003cscript async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"\u003e\u003c/script\u003e\n\u003cp\u003eYou can see the results here:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://twitter.com/alexellisuk/status/1583089248084729856/photo/1\"\u003e\u003cimg src=\"https://pbs.twimg.com/media/FfhC5z1XkAAoYjn?format=jpg\u0026#x26;name=large\" alt=\"Results from the test, side-by-side\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAs a general rule, the download speed is going to be roughly the same with a hosted runner, it may even be slightly faster due to the connection speed of Azure's network.\u003c/p\u003e\n\u003cp\u003eBut the compilation times speak for themselves - in the Parca build, \u003ccode\u003ego test\u003c/code\u003e was being run with QEMU. Moving it to run on the ARM64 host directly, resulted in the marked increase in speed. In fact, the team had introduced lots of complicated code to try and set up a Docker container to use QEMU, all that could be stripped out, replacing it with a very standard looking test step:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e  \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eRun\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ethe\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ego\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etests\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ego\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e./...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eCan't I just install the self-hosted runner on an Arm VM?\u003c/h2\u003e\n\u003cp\u003eThere are relatively cheap Arm VMs available from Oracle OCI, Google and Azure based upon the Ampere Altra CPU. AWS have their own Arm VMs available in the Graviton line.\u003c/p\u003e\n\u003cp\u003eSo why shouldn't you just go ahead and install the runner and add them to your repos?\u003c/p\u003e\n\u003cp\u003eThe moment you do that you run into three issues:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou now have to maintain the software packages installed on that machine\u003c/li\u003e\n\u003cli\u003eIf you use KinD or Docker, you're going to run into conflicts between builds\u003c/li\u003e\n\u003cli\u003eOut of the box scheduling is poor - by default it only runs one build at a time there\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eChasing your tail with package updates, faulty builds due to caching and conflicts is not fun, you may feel like you're saving money, but you are paying with your time and if you have a team, you're paying with their time too.\u003c/p\u003e\n\u003cp\u003eMost importantly, GitHub say that it cannot be used safely with a public repository. There's no security isolation, and state can be left over from one build to the next, including harmful code left intentionally by bad actors, or accidentally from malware.\u003c/p\u003e\n\u003ch2\u003eSo how do we get to a safer, more efficient Arm runner?\u003c/h2\u003e\n\u003cp\u003eThe answer is to get us as close as possible to a hosted runner, but with the benefits of a self-hosted runner.\u003c/p\u003e\n\u003cp\u003eThat's where actuated comes in.\u003c/p\u003e\n\u003cp\u003eWe run a SaaS that manages bare-metal for you, and talks to GitHub upon your behalf to schedule jobs efficiently.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNo need to maintain software, we do that for you with an automated OS image\u003c/li\u003e\n\u003cli\u003eWe use microVMs to isolate builds from each other\u003c/li\u003e\n\u003cli\u003eEvery build is immutable and uses a clean environment\u003c/li\u003e\n\u003cli\u003eWe can schedule multiple builds at once without side-effects\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003emicroVMs on Arm require a bare-metal server, and we have tested all the options available to us. Note that the Arm VMs discussed above do not currently support KVM or nested virtualisation.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea1.metal on AWS - 16 cores / 32GB RAM - 300 USD / mo\u003c/li\u003e\n\u003cli\u003ec3.large.arm64 from \u003ca href=\"https://metal.equinix.com/product/servers/c3-large-arm64/\"\u003eEquinix Metal\u003c/a\u003e with 80 Cores and 256GB RAM - 2.5 USD / hr\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.hetzner.com/dedicated-rootserver/matrix-rx\"\u003eRX-Line\u003c/a\u003e from \u003ca href=\"https://hetzner.com\"\u003eHetzner\u003c/a\u003e with 128GB / 256GB RAM, NVMe \u0026#x26; 80 cores for approx 200-250 EUR / mo.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://amzn.to/3WiSDE7\"\u003eMac Mini M1\u003c/a\u003e - 8 cores / 16GB RAM - tested with Asahi Linux - one-time payment of ~ 1500 USD\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you're already an AWS customer, the a1.metal is a good place to start. If you need expert support, networking and a high speed uplink, you can't beat Equinix Metal (we have access to hardware there and can help you get started) - you can even pay per minute and provision machines via API. The Mac Mini \u0026#x3C;1 has a really fast NVMe and we're running one of these with Asahi Linux for our own Kernel builds for actuated. The RX Line from Hetzner has serious power and is really quite affordable, but just be aware that you're limited to a 1Gbps connection, a setup fee and monthly commitment, unless you pay significantly more.\u003c/p\u003e\n\u003cp\u003eI even tried Frederic's Parca job \u003ca href=\"https://twitter.com/alexellisuk/status/1585228202087415808?s=20\u0026#x26;t=kW-cfn44pQTzUsRiMw32kQ\"\u003eon my 8GB Raspberry Pi with a USB NVMe\u003c/a\u003e. Why even bother, do I hear you say? Well for a one-time payment of 80 USD, it was 26m30s quicker than a hosted runner with QEMU!\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://alexellisuk.medium.com/upgrade-your-raspberry-pi-4-with-a-nvme-boot-drive-d9ab4e8aa3c2\"\u003eLearn how to connect an NVMe over USB-C to your Raspberry Pi 4\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eWhat does an Arm job look like?\u003c/h2\u003e\n\u003cp\u003eSince I first started trying to build code for Arm in 2015, I noticed a group of people who had a passion for this efficient CPU and platform. They would show up on GitHub issue trackers, ready to send patches, get access to hardware and test out new features on Arm chips. It was a tough time, and we should all be grateful for their efforts which go largely unrecognised.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf you're looking to make your \u003ca href=\"https://twitter.com/alexellisuk\"\u003esoftware compatible with Arm\u003c/a\u003e, feel free to reach out to me via Twitter.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn 2020 when Apple released their M1 chip, Arm went mainstream, and projects that had been putting off Arm support like KinD and Minikube, finally had that extra push to get it done.\u003c/p\u003e\n\u003cp\u003eI've had several calls with teams who use Docker on their M1/M2 Macs exclusively, meaning they build only Arm binaries and use only Arm images from the Docker Hub. Some of them even ship to project using Arm images, but I think we're still a little behind the curve there.\u003c/p\u003e\n\u003cp\u003eThat means Kubernetes - KinD/Minikube/K3s and Docker - including Buildkit, compose etc, all work out of the box.\u003c/p\u003e\n\u003cp\u003eI'm going to use the arkade CLI to download KinD and kubectl, however you can absolutely find the download links and do all this manually. I don't recommend it!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ee2e-kind-test\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003eon:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epush\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ejobs:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003estart-kind:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eruns-on:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu-latest\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003esteps:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eactions/checkout@master\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ewith:\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003efetch-depth:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003earkade\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ealexellis/setup-arkade@v1\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekubectl\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eand\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekubectl\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ealexellis/arkade-get@master\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ewith:\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ekubectl:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elatest\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elatest\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eCreate\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eKinD\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecluster\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e|\n          mkdir -p $HOME/.kube/\n          kind create cluster --wait 300s\n\u003c/span\u003e      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eWait\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003euntil\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eCoreDNS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eready\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e|\n          kubectl rollout status deploy/coredns -n kube-system --timeout=300s\n\u003c/span\u003e      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eExplore\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003enodes\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekubectl\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003enodes\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-o\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ewide\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eExplore\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epods\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekubectl\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epod\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-A\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-o\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ewide\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat's our \u003ccode\u003ex86_64\u003c/code\u003e build, or Intel/AMD build that will run on a hosted runner, but will be kind of slow.\u003c/p\u003e\n\u003cp\u003eLet's convert it to run on an actuated ARM64 runner:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-diff\"\u003ejobs:\n  start-kind:\n\u003cspan class=\"hljs-deletion\"\u003e-    runs-on: ubuntu-latest\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+    runs-on: actuated-aarch64\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat's it, we've changed the runner type and we're ready to go.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2023-native-arm64-for-oss/in-progress-dashboard.png\" alt=\"In progress build on the dashboard\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAn in progress build on the dashboard\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eBehind the scenes, actuated, the SaaS schedules the build on a bare-metal ARM64 server, the boot up takes less than 1 second, and then the standard GitHub Actions Runner talks securely to GitHub to run the build. The build is isolated from other builds, and the runner is destroyed after the build is complete.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2023-native-arm64-for-oss/arm-kind.png\" alt=\"Setting up an Arm KinD cluster took about 49s\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSetting up an Arm KinD cluster took about 49s\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSetting up an Arm KinD cluster took about 49s, then it's over to you to test your Arm images, or binaries.\u003c/p\u003e\n\u003cp\u003eIf I were setting up CI and needed to test software on both Arm and x86_64, then I'd probably create two separate builds, one for each architecture, with a \u003ccode\u003eruns-on\u003c/code\u003e label of \u003ccode\u003eactuated\u003c/code\u003e and \u003ccode\u003eactuated-aarch64\u003c/code\u003e respectively.\u003c/p\u003e\n\u003cp\u003eDo you need to test multiple versions of Kubernetes? Let's face it, it changes so often, that who doesn't need to do that. You can use the \u003ccode\u003ematrix\u003c/code\u003e feature to test multiple versions of Kubernetes on Arm and x86_64.\u003c/p\u003e\n\u003cp\u003eI show 5x clusters being launched in parallel in the video below:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=2o28iUC-J1w\"\u003eDemo - Actuated - secure, isolated CI for containers and Kubernetes\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eWhat about Docker?\u003c/p\u003e\n\u003cp\u003eDocker comes pre-installed in the actuated OS images, so you can simply use \u003ccode\u003edocker build\u003c/code\u003e, without any need to install extra tools like Buildx, or to have to worry about multi-arch Dockerfiles. Although these are always good to have, and are \u003ca href=\"https://github.com/openfaas/golang-http-template/blob/master/template/golang-middleware/Dockerfile\"\u003eavailable out of the box in OpenFaaS\u003c/a\u003e, if you're curious what a multi-arch Dockerfile looks like.\u003c/p\u003e\n\u003ch2\u003eWrapping up\u003c/h2\u003e\n\u003cp\u003eBuilding on bare-metal Arm hosts is more secure because side effects cannot be left over between builds, even if malware is installed by a bad actor. It's more efficient because you can run multiple builds at once, and you can use the latest software with our automated Operating System image. Enabling actuated on a build is as simple as changing the runner type.\u003c/p\u003e\n\u003cp\u003eAnd as you've seen from the example with the OSS Parca project, moving to a native Arm server can improve speed by 22x, shaving off a massive 34 minutes per build.\u003c/p\u003e\n\u003cp\u003eWho wouldn't want that?\u003c/p\u003e\n\u003cp\u003eParca isn't a one-off, I was also told by \u003ca href=\"https://twitter.com/cohix\"\u003eConnor Hicks from Suborbital\u003c/a\u003e that they have an Arm build that takes a good 45 minutes due to using QEMU.\u003c/p\u003e\n\u003cp\u003eJust a couple of days ago \u003ca href=\"https://twitter.com/edwarnicke?lang=en\"\u003eEd Warnicke, Distinguished Engineer at Cisco\u003c/a\u003e reached out to us to pilot actuated. Why?\u003c/p\u003e\n\u003cp\u003eEd, who had \u003ca href=\"https://networkservicemesh.io/\"\u003eNetwork Service Mesh\u003c/a\u003e in mind said:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI'd kill for proper Arm support. I'd love to be able to build our many containers for Arm natively, and run our KIND based testing on Arm natively.\nWe want to build for Arm - Arm builds is what brought us to actuated\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo if that sounds like where you are, reach out to us and we'll get you set up.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.google.com/forms/d/e/1FAIpQLScA12IGyVFrZtSAp2Oj24OdaSMloqARSwoxx3AZbQbs0wpGww/viewform\"\u003eRegister to pilot actuated with us\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditional links:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.actuated.dev/\"\u003eActuated docs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.actuated.dev/faq\"\u003eFAQ \u0026#x26; comparison to other solutions\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://twitter.com/selfactuated\"\u003eFollow actuated on Twitter\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"How to make GitHub Actions 22x faster with bare-metal Arm","description":"GitHub doesn't provide hosted Arm runners, so how can you use native Arm runners safely \u0026 securely?","author":"Alex Ellis","tags":["cicd","githubactions","arm","arm64","multiarch"],"author_img":"alex","image":"/images/2023-native-arm64-for-oss/in-progress-dashboard.png","date":"2023-01-17"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"native-arm64-for-github-actions"},"buildId":"gpxkhRF3sNinvQxss-7sT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>