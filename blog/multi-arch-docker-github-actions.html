<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" content="#000000"/><meta name="author" content="OpenFaaS Ltd"/><meta name="twitter:card" content="summary_large_image"/><title>The efficient way to publish multi-arch containers from GitHub Actions</title><meta name="description" content="Learn how to publish container images for both Arm and Intel machines from GitHub Actions."/><meta property="twitter:title" content="The efficient way to publish multi-arch containers from GitHub Actions"/><meta property="twitter:description" content="Learn how to publish container images for both Arm and Intel machines from GitHub Actions."/><meta property="og:title" content="The efficient way to publish multi-arch containers from GitHub Actions"/><meta property="og:description" content="Learn how to publish container images for both Arm and Intel machines from GitHub Actions."/><meta name="twitter:image:src" content="https://actuated.dev/images/2023-02-multi-arch/architecture.jpg"/><meta property="og:image" content="https://actuated.dev/images/2023-02-multi-arch/architecture.jpg"/><meta name="next-head-count" content="13"/><meta charSet="utf-8"/><link rel="icon" type="image/png" href="/images/actuated.png"/><link rel="stylesheet" href="https://rsms.me/inter/inter.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css"/><link rel="manifest" href="/manifest.json"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M5YNDNX7VT"></script><script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-M5YNDNX7VT');
          </script><link rel="apple-touch-icon" href="/images/actuated.png"/><link rel="preload" href="/_next/static/css/931f0fc3815fa31d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/931f0fc3815fa31d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-34e2100d07ae5757.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ba4f0f0b110ca3d9.js" defer=""></script><script src="/_next/static/chunks/552-542f150c917a7625.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-109b0d2eddac75b5.js" defer=""></script><script src="/_next/static/5qTHMXJQ1D9kix0NvcamU/_buildManifest.js" defer=""></script><script src="/_next/static/5qTHMXJQ1D9kix0NvcamU/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-white"><header><div class="relative bg-white" data-headlessui-state=""><div class="mx-auto flex max-w-7xl items-center justify-between px-4 py-6 sm:px-6 md:justify-start md:space-x-10 lg:px-8"><div class="flex justify-start lg:w-0 lg:flex-1"><a href="/"><span class="sr-only">Actuated</span><img class="h-8 w-auto sm:h-10" src="/images/actuated.png" alt="Actuated logo"/></a></div><div class="-my-2 -mr-2 md:hidden"><button class="inline-flex items-center justify-center rounded-md bg-white p-2 text-gray-400 hover:bg-gray-100 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><nav class="hidden space-x-10 md:flex"><div class="relative" data-headlessui-state=""><button class="text-gray-500 group inline-flex items-center rounded-md bg-white text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" type="button" aria-expanded="false" data-headlessui-state=""><span>Solutions</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="/blog">Blog</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="https://actuated.dev/blog/blazing-fast-ci-with-microvms">Announcement</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="/pricing">Pricing</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="https://docs.actuated.dev/">Docs</a></nav><div class="hidden items-center justify-end md:flex md:flex-1 lg:w-0"><a href="https://dashboard.actuated.dev" class="whitespace-nowrap text-base font-medium text-gray-500 hover:text-gray-900">Sign in</a><a href="/pricing" class="ml-8 inline-flex items-center justify-center whitespace-nowrap rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-indigo-700">Sign-up</a></div></div></div></header><main><div class="container mx-auto max-w-4xl bg-white mt-4 px-4 sm:px-6"><h1 id="post_title" class="text-3xl mb-3 leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl sm:leading-10 text-center">The efficient way to publish multi-arch containers from GitHub Actions</h1></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-4xl"><div class="border-b border-gray-200 py-4 flex items-center text-gray-500 mx-auto"><div><img class="h-10 w-10 rounded-full" src="/images/alex.jpg" alt=""/></div><div class="ml-3"><p id="post_author" class="text-sm leading-5 font-medium text-gray-900">Alex Ellis</p><div class="flex text-sm leading-5 text-gray-500"><time dateTime="2023-02-01" id="post_date">February 1, 2023</time><span class="mx-1"></span></div></div></div><div class="mt-6 prose sm:prose-lg max-w-none"><p id="post_description" class="mb-4">Learn how to publish container images for both Arm and Intel machines from GitHub Actions.</p></div><div id="post_content" class="mt-6 prose sm:prose-lg max-w-none"><p>In 2017, I wrote an article on <a href="https://docs.docker.com/build/building/multi-stage/">multi-stage builds with Docker</a>, and it's now part of the Docker Documentation. In my opinion, multi-arch builds were the proceeding step in the evolution of container images.</p>
<h2>What's multi-arch and why should you care?</h2>
<p>If you want users to be able to use your containers on different types of computer, then you'll often need to build different versions of your binaries and containers.</p>
<p>The <a href="https://github.com/openfaas/faas-cli">faas-cli</a> tool is how users interact with <a href="https://github.com/openfaas/faas">OpenFaaS</a>.</p>
<p>It's distributed in binary format for users, with builds for Windows, MacOS and Linux.</p>
<ul>
<li><code>linux/amd64</code>, <code>linux/arm64</code>, <code>linux/arm/v7</code></li>
<li><code>darwin/amd64</code>, <code>darwin/arm64</code></li>
<li><code>windows/amd64</code></li>
</ul>
<p>But why are there six different binaries for three Operating Systems? With the advent of Raspberry Pi, M1 Macs (Apple Silicon) and AWS Graviton servers, we have had to start building binaries for more than just Intel systems.</p>
<p>If you're curious how to build multi-arch binaries with Go, you can check out the release process for the open source arkade tool here, which is a simpler example than faas-cli: <a href="https://github.com/alexellis/arkade/blob/master/Makefile">arkade Makefile</a> and <a href="https://github.com/alexellis/arkade/blob/master/.github/workflows/publish.yml">GitHub Actions publish job</a></p>
<p>So if we have to support at least six different binaries for Open Source CLIs, what about container images?</p>
<h2>Do we need multi-arch containers too?</h2>
<p>Until recently, it was common to hear people say: "I can't find any containers that work for Arm". This was because the majority of container images were built only for Intel. Docker Inc has done a sterling job of making their "official" images work on different platforms, that's why you can now run <code>docker run -t -i ubuntu /bin/bash</code> on a Raspberry Pi, M1 Mac and your regular PC.</p>
<p>Many open source projects have also caught on to the need for multi-arch images, but there are still a few like Bitnami, haven't yet seen value. I think that is OK, this kind work does take time and effort. Ultimately, it's up to the project maintainers to listen to their users and decide if they have enough interest to add support for Arm.</p>
<p>A multi-arch image is a container that will work on two or more different combinations of operating system and CPU architecture.</p>
<p>Typically, this would be:</p>
<ul>
<li><code>linux/amd64</code> - "normal" computers made by Intel or AMD</li>
<li><code>linux/arm64</code> - 64-bit Arm servers like <a href="https://docs.aws.amazon.com/whitepapers/latest/aws-graviton-performance-testing/what-is-aws-graviton.html">AWS Graviton</a> or <a href="https://amperecomputing.com/processors/ampere-altra/">Ampere Altra</a></li>
<li><code>linux/arm/v7</code> - the 32-bit Raspberry Pi Operating System</li>
</ul>
<p>So multi-arch is really about catering for the needs of Arm users. Arm hardware platforms like the Ampere Altra come with 80 efficient CPU cores, have a very low TDP compared to traditional Intel hardware, and are available from various cloud providers.</p>
<h2>How do we build multi-arch containers work?</h2>
<p>There are a few tools and tricks that we can combine together to take a single Dockerfile and output an image that anyone can pull, which will be right for their machine.</p>
<p>Let's take the: <code>ghcr.io/inlets-operator:latest</code> image from <a href="https://inlets.dev/">inlets</a>.</p>
<p>When a user types in <code>docker pull</code>, or deploys a Pod to Kubernetes, their local containerd daemon will fetch the manifest file and inspect it to see what SHA reference to use for to download the required layers for the image.</p>
<p><img src="/images/2023-02-multi-arch/multi-arch.png" alt="How manifests work"></p>
<blockquote>
<p>How manifests work</p>
</blockquote>
<p>Let's look at a manifest file with the crane tool. I'm going to use <a href="https://arkade.dev">arkade</a> to install crane:</p>
<pre><code class="hljs language-bash">arkade get crane

crane manifest ghcr.io/inlets/inlets-operator:latest
</code></pre>
<p>You'll see a manifests array, with a platform section for each image:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mediaType"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"application/vnd.docker.distribution.manifest.list.v2+json"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"manifests"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"mediaType"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"application/vnd.docker.distribution.manifest.v2+json"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"digest"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"sha256:bae8025e080d05f1db0e337daae54016ada179152e44613bf3f8c4243ad939df"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"platform"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"architecture"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"amd64"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"os"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"linux"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"mediaType"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"application/vnd.docker.distribution.manifest.v2+json"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"digest"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"sha256:3ddc045e2655f06653fc36ac88d1d85e0f077c111a3d1abf01d05e6bbc79c89f"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"platform"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"architecture"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"arm64"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"os"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"linux"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2>How do we convert a Dockerfile to multi-arch?</h2>
<p>Instead of using the classic version of Docker, we can enable the buildx and Buildkit plugins which provide a way to build multi-arch images.</p>
<p>We'll continue with the Dockerfile from the open source inlets-operator project.</p>
<p>Within <a href="https://github.com/inlets/inlets-operator/blob/master/Dockerfile">the Dockerfile</a>, we need to make a couple of changes.</p>
<pre><code class="hljs language-diff"><span class="hljs-deletion">- FROM golang:1.18 as builder</span>
<span class="hljs-addition">+ FROM --platform=${BUILDPLATFORM:-linux/amd64} golang:1.18 as builder</span>

<span class="hljs-addition">+ ARG TARGETPLATFORM</span>
<span class="hljs-addition">+ ARG BUILDPLATFORM</span>
<span class="hljs-addition">+ ARG TARGETOS</span>
<span class="hljs-addition">+ ARG TARGETARCH</span>
</code></pre>
<p>The BUILDPLATFORM variable is the native architecture and platform of the machine performing the build, this is usually amd64.</p>
<p>The TARGETPLATFORM is important for the final step of the build, and will normally be injected based upon one each of the platforms you have specified for the build command.</p>
<p>For Go specifically, we also updated the <code>go build</code> command to tell Go to use cross-compilation based upon the TARGETOS and TARGETARCH environment variables, which are populated by Docker.</p>
<pre><code class="hljs language-diff"><span class="hljs-deletion">- go build -o inlets-operator</span>
<span class="hljs-addition">+ GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -o inlets-operator</span>
</code></pre>
<p>Here's the full example:</p>
<pre><code>FROM --platform=${BUILDPLATFORM:-linux/amd64} golang:1.18 as builder

ARG TARGETPLATFORM
ARG BUILDPLATFORM
ARG TARGETOS
ARG TARGETARCH

ARG Version
ARG GitCommit

ENV CGO_ENABLED=0
ENV GO111MODULE=on

WORKDIR /go/src/github.com/inlets/inlets-operator

# Cache the download before continuing
COPY go.mod go.mod
COPY go.sum go.sum
RUN go mod download

COPY .  .

RUN CGO_ENABLED=${CGO_ENABLED} GOOS=${TARGETOS} GOARCH=${TARGETARCH} \
  go test -v ./...

RUN CGO_ENABLED=${CGO_ENABLED} GOOS=${TARGETOS} GOARCH=${TARGETARCH} \
  go build -ldflags "-s -w -X github.com/inlets/inlets-operator/pkg/version.Release=${Version} -X github.com/inlets/inlets-operator/pkg/version.SHA=${GitCommit}" \
  -a -installsuffix cgo -o /usr/bin/inlets-operator .

FROM --platform=${BUILDPLATFORM:-linux/amd64} gcr.io/distroless/static:nonroot

LABEL org.opencontainers.image.source=https://github.com/inlets/inlets-operator

WORKDIR /
COPY --from=builder /usr/bin/inlets-operator /
USER nonroot:nonroot

CMD ["/inlets-operator"]
</code></pre>
<h2>How to do you configure GitHub Actions to publish multi-arch images?</h2>
<p>Now that the Dockerfile has been configured, it's time to start working on the GitHub Action.</p>
<p>This example is taken from the Open Source <a href="https://github.com/inlets/inlets-operator">inlets-operator</a>. It builds a container image containing a Go binary and uses a Dockerfile in the root of the repository.</p>
<p>View <a href="https://github.com/inlets/inlets-operator/blob/master/.github/workflows/publish.yaml">publish.yaml</a>, adapted for actuated:</p>
<pre><code class="hljs language-diff">name: publish

on:
  push:
    tags:
      - '*'

jobs:
  publish:
<span class="hljs-addition">+    permissions:</span>
<span class="hljs-addition">+      packages: write</span>

<span class="hljs-deletion">-   runs-on: ubuntu-latest</span>
<span class="hljs-addition">+   runs-on: actuated</span>
    steps:
      - uses: actions/checkout@master
        with:
          fetch-depth: 1

<span class="hljs-addition">+     - name: Setup mirror</span>
<span class="hljs-addition">+       uses: self-actuated/hub-mirror@master</span>
      - name: Get TAG
        id: get_tag
        run: echo TAG=${GITHUB_REF#refs/tags/} >> $GITHUB_ENV
      - name: Get Repo Owner
        id: get_repo_owner
        run: echo "REPO_OWNER=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')" > $GITHUB_ENV

<span class="hljs-addition">+     - name: Set up QEMU</span>
<span class="hljs-addition">+       uses: docker/setup-qemu-action@v2</span>
<span class="hljs-addition">+     - name: Set up Docker Buildx</span>
<span class="hljs-addition">+       uses: docker/setup-buildx-action@v2</span>
      - name: Login to container Registry
        uses: docker/login-action@v2
        with:
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
          registry: ghcr.io

      - name: Release build
        id: release_build
        uses: docker/build-push-action@v4
        with:
          outputs: "type=registry,push=true"
          provenance: false
<span class="hljs-addition">+         platforms: linux/amd64,linux/arm/v6,linux/arm64</span>
          build-args: |
            Version=${{  env.TAG }}
            GitCommit=${{ github.sha }}
          tags: |
            ghcr.io/${{ env.REPO_OWNER }}/inlets-operator:${{ github.sha }}
            ghcr.io/${{ env.REPO_OWNER }}/inlets-operator:${{ env.TAG }}
            ghcr.io/${{ env.REPO_OWNER }}/inlets-operator:latest
</code></pre>
<p>All of the images and corresponding manifest are published to GitHub's Container Registry (GHCR). The action itself is able to authenticate to GHCR using a built-in, short-lived token. This is dependent on the "permissions" section and "packages: write" being set.</p>
<p>You'll see that we added a <code>Setup mirror</code> step, this explained in the <a href="/examples/registry-mirror">Registry Mirror example</a> and is not required for Hosted Runners.</p>
<p>The <code>docker/setup-qemu-action@v2</code> step is responsible for setting up QEMU, which is used to emulate the different CPU architectures.</p>
<p>The <code>docker/build-push-action@v4</code> step is responsible for passing in a number of platform combinations such as: <code>linux/amd64</code> for cloud, <code>linux/arm64</code> for Arm servers and <code>linux/arm/v6</code> for Raspberry Pi.</p>
<h2>What if you're not using GitHub Actions?</h2>
<p>The various GitHub Actions published by the Docker team are a great way to get started, but if you look under the hood, they're just syntactic sugar for the Docker CLI.</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">export</span> DOCKER_CLI_EXPERIMENTAL=enabled

<span class="hljs-comment"># Have Docker download the latest buildx plugin</span>
docker buildx install

<span class="hljs-comment"># Create a buildkit daemon with the name "multiarch"</span>
docker buildx create \
    --use \
    --name=multiarch \
    --node=multiarch

<span class="hljs-comment"># Install QEMU</span>
docker run --<span class="hljs-built_in">rm</span> --privileged \
    multiarch/qemu-user-static --reset -p <span class="hljs-built_in">yes</span>

<span class="hljs-comment"># Run a build for the different platforms</span>
docker buildx build \
    --platform=linux/arm64,linux/amd64 \
    --output=<span class="hljs-built_in">type</span>=registry,push=<span class="hljs-literal">true</span> --tag image:tag .
</code></pre>
<p>For OpenFaaS users, we do all of the above any time you type in <code>faas-cli publish</code> and the <code>faas-cli build</code> command just runs a regular Docker build, without any of the multi-arch steps.</p>
<p>If you're interested, you can checkout the code here: <a href="https://github.com/openfaas/faas-cli/blob/master/commands/publish.go">publish.go</a>.</p>
<h2>Putting it all together</h2>
<ul>
<li>CLIs are published for many different combinations of OS and CPU, but containers are usually only required for Linux with an amd64 or Arm CPU.</li>
<li>Multi-arch images work through a manifest, which then tells containerd which image is needs for the platform it is running on.</li>
<li>QEMU is a tool for emulating different CPU architectures, and is used to build the images for the different platforms.</li>
</ul>
<p>In our experience with OpenFaaS, inlets and actuated, once you have converted one or two projects to build multi-arch images, it becomes a lot easier to do it again, and make all software available for Arm servers.</p>
<p>You can learn more about <a href="https://docs.docker.com/build/building/multi-platform/">Multi-platform images</a> in the Docker Documentation.</p>
<p><em>Want more multi-arch examples?</em></p>
<p>OpenFaaS uses multi-arch Dockerfiles for all of its templates, and the examples are freely available on GitHub including Python, Node, Java and Go.</p>
<p>See also: <a href="https://github.com/openfaas/templates">OpenFaaS templates</a></p>
<p><em>A word of caution</em></p>
<p>QEMU can be incredibly slow at times when using a hosted runner, where a build takes takes 1-2 minutes can extend to over half an hour. If you do run into that, one option is to check out actuated or another solution, which can build directly on an Arm server with a securely isolated Virtual Machine.</p>
<p>In <a href="https://actuated.dev/blog/native-arm64-for-github-actions">How to make GitHub Actions 22x faster with bare-metal Arm</a>, we showed how we decreased the build time of an open-source Go project from 30.5 mins to 1.5 mins. If this is the direction you go in, you can use a <a href="https://docs.actuated.dev/examples/matrix/">matrix-build</a> instead of a QEMU-based multi-arch build.</p>
<p>See also: <a href="https://docs.actuated.dev/provision-server/#arm64-aka-aarch64">Recommended bare-metal Arm servers</a></p></div></div></main><footer class="bg-white"><div class="mx-auto max-w-7xl py-12 px-4 sm:px-6 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-400 hover:text-gray-500" href="https://twitter.com/selfactuated"><span class="sr-only">Twitter</span><svg fill="currentColor" viewBox="0 0 24 24" class="h-6 w-6" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg></a><a class="text-gray-400 hover:text-gray-500" href="https://github.com/self-actuated"><span class="sr-only">GitHub</span><svg fill="currentColor" viewBox="0 0 24 24" class="h-6 w-6" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"></path></svg></a><a class="text-gray-400 hover:text-gray-500" href="/rss.xml"><span class="sr-only">RSS</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-6 w-6" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M12.75 19.5v-.75a7.5 7.5 0 00-7.5-7.5H4.5m0-6.75h.75c7.87 0 14.25 6.38 14.25 14.25v.75M6 18.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0z"></path></svg></a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-base text-gray-400">Â© 2022 <a href="https://openfaas.com">OpenFaaS Ltd</a>, Inc. All rights reserved.</p></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"multi-arch-docker-github-actions","fileName":"2023-02-01-multi-arch-docker-github-actions.md","contentHtml":"\u003cp\u003eIn 2017, I wrote an article on \u003ca href=\"https://docs.docker.com/build/building/multi-stage/\"\u003emulti-stage builds with Docker\u003c/a\u003e, and it's now part of the Docker Documentation. In my opinion, multi-arch builds were the proceeding step in the evolution of container images.\u003c/p\u003e\n\u003ch2\u003eWhat's multi-arch and why should you care?\u003c/h2\u003e\n\u003cp\u003eIf you want users to be able to use your containers on different types of computer, then you'll often need to build different versions of your binaries and containers.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"https://github.com/openfaas/faas-cli\"\u003efaas-cli\u003c/a\u003e tool is how users interact with \u003ca href=\"https://github.com/openfaas/faas\"\u003eOpenFaaS\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIt's distributed in binary format for users, with builds for Windows, MacOS and Linux.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elinux/amd64\u003c/code\u003e, \u003ccode\u003elinux/arm64\u003c/code\u003e, \u003ccode\u003elinux/arm/v7\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edarwin/amd64\u003c/code\u003e, \u003ccode\u003edarwin/arm64\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewindows/amd64\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut why are there six different binaries for three Operating Systems? With the advent of Raspberry Pi, M1 Macs (Apple Silicon) and AWS Graviton servers, we have had to start building binaries for more than just Intel systems.\u003c/p\u003e\n\u003cp\u003eIf you're curious how to build multi-arch binaries with Go, you can check out the release process for the open source arkade tool here, which is a simpler example than faas-cli: \u003ca href=\"https://github.com/alexellis/arkade/blob/master/Makefile\"\u003earkade Makefile\u003c/a\u003e and \u003ca href=\"https://github.com/alexellis/arkade/blob/master/.github/workflows/publish.yml\"\u003eGitHub Actions publish job\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSo if we have to support at least six different binaries for Open Source CLIs, what about container images?\u003c/p\u003e\n\u003ch2\u003eDo we need multi-arch containers too?\u003c/h2\u003e\n\u003cp\u003eUntil recently, it was common to hear people say: \"I can't find any containers that work for Arm\". This was because the majority of container images were built only for Intel. Docker Inc has done a sterling job of making their \"official\" images work on different platforms, that's why you can now run \u003ccode\u003edocker run -t -i ubuntu /bin/bash\u003c/code\u003e on a Raspberry Pi, M1 Mac and your regular PC.\u003c/p\u003e\n\u003cp\u003eMany open source projects have also caught on to the need for multi-arch images, but there are still a few like Bitnami, haven't yet seen value. I think that is OK, this kind work does take time and effort. Ultimately, it's up to the project maintainers to listen to their users and decide if they have enough interest to add support for Arm.\u003c/p\u003e\n\u003cp\u003eA multi-arch image is a container that will work on two or more different combinations of operating system and CPU architecture.\u003c/p\u003e\n\u003cp\u003eTypically, this would be:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elinux/amd64\u003c/code\u003e - \"normal\" computers made by Intel or AMD\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elinux/arm64\u003c/code\u003e - 64-bit Arm servers like \u003ca href=\"https://docs.aws.amazon.com/whitepapers/latest/aws-graviton-performance-testing/what-is-aws-graviton.html\"\u003eAWS Graviton\u003c/a\u003e or \u003ca href=\"https://amperecomputing.com/processors/ampere-altra/\"\u003eAmpere Altra\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elinux/arm/v7\u003c/code\u003e - the 32-bit Raspberry Pi Operating System\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo multi-arch is really about catering for the needs of Arm users. Arm hardware platforms like the Ampere Altra come with 80 efficient CPU cores, have a very low TDP compared to traditional Intel hardware, and are available from various cloud providers.\u003c/p\u003e\n\u003ch2\u003eHow do we build multi-arch containers work?\u003c/h2\u003e\n\u003cp\u003eThere are a few tools and tricks that we can combine together to take a single Dockerfile and output an image that anyone can pull, which will be right for their machine.\u003c/p\u003e\n\u003cp\u003eLet's take the: \u003ccode\u003eghcr.io/inlets-operator:latest\u003c/code\u003e image from \u003ca href=\"https://inlets.dev/\"\u003einlets\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWhen a user types in \u003ccode\u003edocker pull\u003c/code\u003e, or deploys a Pod to Kubernetes, their local containerd daemon will fetch the manifest file and inspect it to see what SHA reference to use for to download the required layers for the image.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2023-02-multi-arch/multi-arch.png\" alt=\"How manifests work\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHow manifests work\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eLet's look at a manifest file with the crane tool. I'm going to use \u003ca href=\"https://arkade.dev\"\u003earkade\u003c/a\u003e to install crane:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003earkade get crane\n\ncrane manifest ghcr.io/inlets/inlets-operator:latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou'll see a manifests array, with a platform section for each image:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"mediaType\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"application/vnd.docker.distribution.manifest.list.v2+json\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"manifests\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\n    \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003e\"mediaType\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"application/vnd.docker.distribution.manifest.v2+json\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003e\"digest\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"sha256:bae8025e080d05f1db0e337daae54016ada179152e44613bf3f8c4243ad939df\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003e\"platform\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e\"architecture\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"amd64\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e\"os\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"linux\"\u003c/span\u003e\n      \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003e\"mediaType\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"application/vnd.docker.distribution.manifest.v2+json\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003e\"digest\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"sha256:3ddc045e2655f06653fc36ac88d1d85e0f077c111a3d1abf01d05e6bbc79c89f\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003e\"platform\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e\"architecture\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"arm64\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e\"os\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"linux\"\u003c/span\u003e\n      \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eHow do we convert a Dockerfile to multi-arch?\u003c/h2\u003e\n\u003cp\u003eInstead of using the classic version of Docker, we can enable the buildx and Buildkit plugins which provide a way to build multi-arch images.\u003c/p\u003e\n\u003cp\u003eWe'll continue with the Dockerfile from the open source inlets-operator project.\u003c/p\u003e\n\u003cp\u003eWithin \u003ca href=\"https://github.com/inlets/inlets-operator/blob/master/Dockerfile\"\u003ethe Dockerfile\u003c/a\u003e, we need to make a couple of changes.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-diff\"\u003e\u003cspan class=\"hljs-deletion\"\u003e- FROM golang:1.18 as builder\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+ FROM --platform=${BUILDPLATFORM:-linux/amd64} golang:1.18 as builder\u003c/span\u003e\n\n\u003cspan class=\"hljs-addition\"\u003e+ ARG TARGETPLATFORM\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+ ARG BUILDPLATFORM\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+ ARG TARGETOS\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+ ARG TARGETARCH\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe BUILDPLATFORM variable is the native architecture and platform of the machine performing the build, this is usually amd64.\u003c/p\u003e\n\u003cp\u003eThe TARGETPLATFORM is important for the final step of the build, and will normally be injected based upon one each of the platforms you have specified for the build command.\u003c/p\u003e\n\u003cp\u003eFor Go specifically, we also updated the \u003ccode\u003ego build\u003c/code\u003e command to tell Go to use cross-compilation based upon the TARGETOS and TARGETARCH environment variables, which are populated by Docker.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-diff\"\u003e\u003cspan class=\"hljs-deletion\"\u003e- go build -o inlets-operator\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+ GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -o inlets-operator\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere's the full example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFROM --platform=${BUILDPLATFORM:-linux/amd64} golang:1.18 as builder\n\nARG TARGETPLATFORM\nARG BUILDPLATFORM\nARG TARGETOS\nARG TARGETARCH\n\nARG Version\nARG GitCommit\n\nENV CGO_ENABLED=0\nENV GO111MODULE=on\n\nWORKDIR /go/src/github.com/inlets/inlets-operator\n\n# Cache the download before continuing\nCOPY go.mod go.mod\nCOPY go.sum go.sum\nRUN go mod download\n\nCOPY .  .\n\nRUN CGO_ENABLED=${CGO_ENABLED} GOOS=${TARGETOS} GOARCH=${TARGETARCH} \\\n  go test -v ./...\n\nRUN CGO_ENABLED=${CGO_ENABLED} GOOS=${TARGETOS} GOARCH=${TARGETARCH} \\\n  go build -ldflags \"-s -w -X github.com/inlets/inlets-operator/pkg/version.Release=${Version} -X github.com/inlets/inlets-operator/pkg/version.SHA=${GitCommit}\" \\\n  -a -installsuffix cgo -o /usr/bin/inlets-operator .\n\nFROM --platform=${BUILDPLATFORM:-linux/amd64} gcr.io/distroless/static:nonroot\n\nLABEL org.opencontainers.image.source=https://github.com/inlets/inlets-operator\n\nWORKDIR /\nCOPY --from=builder /usr/bin/inlets-operator /\nUSER nonroot:nonroot\n\nCMD [\"/inlets-operator\"]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eHow to do you configure GitHub Actions to publish multi-arch images?\u003c/h2\u003e\n\u003cp\u003eNow that the Dockerfile has been configured, it's time to start working on the GitHub Action.\u003c/p\u003e\n\u003cp\u003eThis example is taken from the Open Source \u003ca href=\"https://github.com/inlets/inlets-operator\"\u003einlets-operator\u003c/a\u003e. It builds a container image containing a Go binary and uses a Dockerfile in the root of the repository.\u003c/p\u003e\n\u003cp\u003eView \u003ca href=\"https://github.com/inlets/inlets-operator/blob/master/.github/workflows/publish.yaml\"\u003epublish.yaml\u003c/a\u003e, adapted for actuated:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-diff\"\u003ename: publish\n\non:\n  push:\n    tags:\n      - '*'\n\njobs:\n  publish:\n\u003cspan class=\"hljs-addition\"\u003e+    permissions:\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+      packages: write\u003c/span\u003e\n\n\u003cspan class=\"hljs-deletion\"\u003e-   runs-on: ubuntu-latest\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+   runs-on: actuated\u003c/span\u003e\n    steps:\n      - uses: actions/checkout@master\n        with:\n          fetch-depth: 1\n\n\u003cspan class=\"hljs-addition\"\u003e+     - name: Setup mirror\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+       uses: self-actuated/hub-mirror@master\u003c/span\u003e\n      - name: Get TAG\n        id: get_tag\n        run: echo TAG=${GITHUB_REF#refs/tags/} \u003e\u003e $GITHUB_ENV\n      - name: Get Repo Owner\n        id: get_repo_owner\n        run: echo \"REPO_OWNER=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')\" \u003e $GITHUB_ENV\n\n\u003cspan class=\"hljs-addition\"\u003e+     - name: Set up QEMU\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+       uses: docker/setup-qemu-action@v2\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+     - name: Set up Docker Buildx\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+       uses: docker/setup-buildx-action@v2\u003c/span\u003e\n      - name: Login to container Registry\n        uses: docker/login-action@v2\n        with:\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n          registry: ghcr.io\n\n      - name: Release build\n        id: release_build\n        uses: docker/build-push-action@v4\n        with:\n          outputs: \"type=registry,push=true\"\n          provenance: false\n\u003cspan class=\"hljs-addition\"\u003e+         platforms: linux/amd64,linux/arm/v6,linux/arm64\u003c/span\u003e\n          build-args: |\n            Version=${{  env.TAG }}\n            GitCommit=${{ github.sha }}\n          tags: |\n            ghcr.io/${{ env.REPO_OWNER }}/inlets-operator:${{ github.sha }}\n            ghcr.io/${{ env.REPO_OWNER }}/inlets-operator:${{ env.TAG }}\n            ghcr.io/${{ env.REPO_OWNER }}/inlets-operator:latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAll of the images and corresponding manifest are published to GitHub's Container Registry (GHCR). The action itself is able to authenticate to GHCR using a built-in, short-lived token. This is dependent on the \"permissions\" section and \"packages: write\" being set.\u003c/p\u003e\n\u003cp\u003eYou'll see that we added a \u003ccode\u003eSetup mirror\u003c/code\u003e step, this explained in the \u003ca href=\"/examples/registry-mirror\"\u003eRegistry Mirror example\u003c/a\u003e and is not required for Hosted Runners.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003edocker/setup-qemu-action@v2\u003c/code\u003e step is responsible for setting up QEMU, which is used to emulate the different CPU architectures.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003edocker/build-push-action@v4\u003c/code\u003e step is responsible for passing in a number of platform combinations such as: \u003ccode\u003elinux/amd64\u003c/code\u003e for cloud, \u003ccode\u003elinux/arm64\u003c/code\u003e for Arm servers and \u003ccode\u003elinux/arm/v6\u003c/code\u003e for Raspberry Pi.\u003c/p\u003e\n\u003ch2\u003eWhat if you're not using GitHub Actions?\u003c/h2\u003e\n\u003cp\u003eThe various GitHub Actions published by the Docker team are a great way to get started, but if you look under the hood, they're just syntactic sugar for the Docker CLI.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e DOCKER_CLI_EXPERIMENTAL=enabled\n\n\u003cspan class=\"hljs-comment\"\u003e# Have Docker download the latest buildx plugin\u003c/span\u003e\ndocker buildx install\n\n\u003cspan class=\"hljs-comment\"\u003e# Create a buildkit daemon with the name \"multiarch\"\u003c/span\u003e\ndocker buildx create \\\n    --use \\\n    --name=multiarch \\\n    --node=multiarch\n\n\u003cspan class=\"hljs-comment\"\u003e# Install QEMU\u003c/span\u003e\ndocker run --\u003cspan class=\"hljs-built_in\"\u003erm\u003c/span\u003e --privileged \\\n    multiarch/qemu-user-static --reset -p \u003cspan class=\"hljs-built_in\"\u003eyes\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# Run a build for the different platforms\u003c/span\u003e\ndocker buildx build \\\n    --platform=linux/arm64,linux/amd64 \\\n    --output=\u003cspan class=\"hljs-built_in\"\u003etype\u003c/span\u003e=registry,push=\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e --tag image:tag .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor OpenFaaS users, we do all of the above any time you type in \u003ccode\u003efaas-cli publish\u003c/code\u003e and the \u003ccode\u003efaas-cli build\u003c/code\u003e command just runs a regular Docker build, without any of the multi-arch steps.\u003c/p\u003e\n\u003cp\u003eIf you're interested, you can checkout the code here: \u003ca href=\"https://github.com/openfaas/faas-cli/blob/master/commands/publish.go\"\u003epublish.go\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003ePutting it all together\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCLIs are published for many different combinations of OS and CPU, but containers are usually only required for Linux with an amd64 or Arm CPU.\u003c/li\u003e\n\u003cli\u003eMulti-arch images work through a manifest, which then tells containerd which image is needs for the platform it is running on.\u003c/li\u003e\n\u003cli\u003eQEMU is a tool for emulating different CPU architectures, and is used to build the images for the different platforms.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn our experience with OpenFaaS, inlets and actuated, once you have converted one or two projects to build multi-arch images, it becomes a lot easier to do it again, and make all software available for Arm servers.\u003c/p\u003e\n\u003cp\u003eYou can learn more about \u003ca href=\"https://docs.docker.com/build/building/multi-platform/\"\u003eMulti-platform images\u003c/a\u003e in the Docker Documentation.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eWant more multi-arch examples?\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eOpenFaaS uses multi-arch Dockerfiles for all of its templates, and the examples are freely available on GitHub including Python, Node, Java and Go.\u003c/p\u003e\n\u003cp\u003eSee also: \u003ca href=\"https://github.com/openfaas/templates\"\u003eOpenFaaS templates\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eA word of caution\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eQEMU can be incredibly slow at times when using a hosted runner, where a build takes takes 1-2 minutes can extend to over half an hour. If you do run into that, one option is to check out actuated or another solution, which can build directly on an Arm server with a securely isolated Virtual Machine.\u003c/p\u003e\n\u003cp\u003eIn \u003ca href=\"https://actuated.dev/blog/native-arm64-for-github-actions\"\u003eHow to make GitHub Actions 22x faster with bare-metal Arm\u003c/a\u003e, we showed how we decreased the build time of an open-source Go project from 30.5 mins to 1.5 mins. If this is the direction you go in, you can use a \u003ca href=\"https://docs.actuated.dev/examples/matrix/\"\u003ematrix-build\u003c/a\u003e instead of a QEMU-based multi-arch build.\u003c/p\u003e\n\u003cp\u003eSee also: \u003ca href=\"https://docs.actuated.dev/provision-server/#arm64-aka-aarch64\"\u003eRecommended bare-metal Arm servers\u003c/a\u003e\u003c/p\u003e","title":"The efficient way to publish multi-arch containers from GitHub Actions","description":"Learn how to publish container images for both Arm and Intel machines from GitHub Actions.","author":"Alex Ellis","tags":["security","oss","multiarch"],"author_img":"alex","image":"/images/2023-02-multi-arch/architecture.jpg","date":"2023-02-01"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"multi-arch-docker-github-actions"},"buildId":"5qTHMXJQ1D9kix0NvcamU","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>