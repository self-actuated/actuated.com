<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" content="#000000"/><meta name="author" content="OpenFaaS Ltd"/><meta name="twitter:card" content="summary_large_image"/><title>How secure are containers &amp; Kubernetes vs. microVMs for self-hosted CI?</title><meta name="description" content="How secure are your self-hosted CI runners? We compare running CI jobs on VMs, containers, and Kubernetes versus one-shot, ephemeral microVMs."/><meta property="twitter:title" content="How secure are containers &amp; Kubernetes vs. microVMs for self-hosted CI?"/><meta property="twitter:description" content="How secure are your self-hosted CI runners? We compare running CI jobs on VMs, containers, and Kubernetes versus one-shot, ephemeral microVMs."/><meta property="og:title" content="How secure are containers &amp; Kubernetes vs. microVMs for self-hosted CI?"/><meta property="og:description" content="How secure are your self-hosted CI runners? We compare running CI jobs on VMs, containers, and Kubernetes versus one-shot, ephemeral microVMs."/><meta name="twitter:image:src" content="https://actuated.com/images/2024-10-containers-vs-microvms/background.png"/><meta property="og:image" content="https://actuated.com/images/2024-10-containers-vs-microvms/background.png"/><meta name="next-head-count" content="13"/><meta charSet="utf-8"/><link rel="icon" type="image/png" href="/images/actuated.png"/><link rel="stylesheet" href="https://rsms.me/inter/inter.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css"/><link rel="manifest" href="/manifest.json"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M5YNDNX7VT"></script><script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-M5YNDNX7VT');
          </script><link rel="apple-touch-icon" href="/images/actuated.png"/><link rel="preload" href="/_next/static/css/702f6a6fb06b3438.css" as="style"/><link rel="stylesheet" href="/_next/static/css/702f6a6fb06b3438.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-34e2100d07ae5757.js" defer=""></script><script src="/_next/static/chunks/pages/_app-70ff176000ac1f10.js" defer=""></script><script src="/_next/static/chunks/552-542f150c917a7625.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-386521db085c1ba3.js" defer=""></script><script src="/_next/static/TgOuHhQDJRTA5mcfvYzxs/_buildManifest.js" defer=""></script><script src="/_next/static/TgOuHhQDJRTA5mcfvYzxs/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="bg-white"><header><div class="relative bg-white" data-headlessui-state=""><div class="mx-auto flex max-w-7xl items-center justify-between px-4 py-6 sm:px-6 md:justify-start md:space-x-10 lg:px-8"><div class="flex justify-start lg:w-0 lg:flex-1"><a href="/"><span class="sr-only">Actuated</span><img class="h-8 w-auto sm:h-10" src="/images/actuated.png" alt="Actuated logo"/></a></div><div class="-my-2 -mr-2 md:hidden"><button class="inline-flex items-center justify-center rounded-md bg-white p-2 text-gray-400 hover:bg-gray-100 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><nav class="hidden space-x-10 md:flex"><div class="relative" data-headlessui-state=""><button class="text-gray-500 group inline-flex items-center rounded-md bg-white text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" type="button" aria-expanded="false" data-headlessui-state=""><span>Solutions</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="/blog">Blog</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="/blog/blazing-fast-ci-with-microvms">Announcement</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="/pricing">Pricing</a><a class="text-base font-medium text-gray-500 hover:text-gray-900" href="https://docs.actuated.com/">Docs</a></nav><div class="hidden items-center justify-end md:flex md:flex-1 lg:w-0"><a href="https://dashboard.actuated.com" class="whitespace-nowrap text-base font-medium text-gray-500 hover:text-gray-900">Sign in</a><a href="/pricing" class="ml-8 inline-flex items-center justify-center whitespace-nowrap rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-indigo-700">Sign-up</a></div></div></div></header><main><div class="container mx-auto max-w-4xl bg-white mt-4 px-4 sm:px-6"><h1 id="post_title" class="text-3xl mb-3 leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl sm:leading-10 text-center">How secure are containers &amp; Kubernetes vs. microVMs for self-hosted CI?</h1></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-4xl"><div class="border-b border-gray-200 py-4 flex items-center text-gray-500 mx-auto"><div><img class="h-10 w-10 rounded-full" src="/images/alex.jpg" alt=""/></div><div class="ml-3"><p id="post_author" class="text-sm leading-5 font-medium text-gray-900"></p><div class="flex text-sm leading-5 text-gray-500"><time dateTime="2024-10-23" id="post_date">October 23, 2024</time><span class="mx-1"></span></div></div></div><div class="mt-6 prose sm:prose-lg max-w-none"><p id="post_description" class="mb-4">How secure are your self-hosted CI runners? We compare running CI jobs on VMs, containers, and Kubernetes versus one-shot, ephemeral microVMs.</p></div><div id="post_content" class="mt-6 prose sm:prose-lg max-w-none"><blockquote>
<p>You've landed here because you're looking for a secure way to run self-hosted CI runners. Our solution isolates CI jobs in one-shot, ephemeral microVMs, but you might be wondering: Why microVMs? Why not just install a self-hosted runner on a VM or use Kubernetes?</p>
</blockquote>
<p>These are valid questions. If you've never considered the security implications of these setups, take a moment to see why microVMs offer a secure alternative.</p>
<p>As of today, we've processed 4.4 million minutes of CI jobs for commercial and <a href="/blog/millions-of-cncf-minutes">open-source CNCF projects</a>, all running in securely isolated microVMs that boot in under a second and are destroyed immediately after the job completes. Some customers use a pool of servers that we manage as part of the subscription, and others have their own dedicated bare-metal hardware rented from <a href="https://docs.actuated.com/provision-server/">cloud providers like Hetzner or Equinix</a>.</p>
<p>This article will walk you through the risks of common self-hosted CI solutions and why microVMs are the safest choice.</p>
<ul>
<li>What does GitHub have to say about self-hosted runner security?</li>
<li>The side effects of an uncontained self-hosted runner</li>
<li>Kubernetes and Docker are secure and ephemeral right?</li>
<li>So what's the alternative?</li>
<li>Wrapping up &#x26; further resources</li>
</ul>
<p>It's not the first time I've spoken on this topic, you'll find a recording from a conference talk I gave, and a link to the <a href="https://actuated.com/blog/blazing-fast-ci-with-microvms">original announcement</a> over two years ago.</p>
<h2 id="what-does-github-have-to-say-about-self-hosted-runner-security">What does GitHub have to say about self-hosted runner security?</h2>
<p>According to <a href="https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#self-hosted-runner-security">Self-hosted runner security</a>:</p>
<blockquote>
<p>We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.</p>
</blockquote>
<blockquote>
<p>This is not an issue with GitHub-hosted runners because each GitHub-hosted runner is always a clean isolated virtual machine, and it is destroyed at the end of the job execution.</p>
</blockquote>
<blockquote>
<p>Untrusted workflows running on your self-hosted runner pose significant security risks for your machine and network environment, especially if your machine persists its environment between jobs. Some of the risks include:</p>
</blockquote>
<ul>
<li>Malicious programs running on the machine.</li>
<li>Escaping the machine's runner sandbox.</li>
<li>Exposing access to the machine's network environment.</li>
<li>Persisting unwanted or dangerous data on the machine.</li>
</ul>
<h2 id="the-side-effects-of-an-uncontained-self-hosted-runner">The side effects of an uncontained self-hosted runner</h2>
<p>My earliest memory of the self-hosted runner went a little bit like this.</p>
<ul>
<li>OK that was easy, what is everyone complaining about?</li>
<li><em>Runs my first job</em> - oh that apt package is missing, let me install it..</li>
<li><em>Goes red again</em> - oh yeah, better add that too</li>
<li>And that one</li>
<li>50 minutes into the build and something else is missing 🤦‍♂️</li>
</ul>
<p>Just installing all the dependencies into your VM that are in the hosted runner, to get some semblance of parity is an arduous task and an ever moving target.</p>
<p>Next, you create a KinD cluster and it goes well for the first run.</p>
<p>The same job that passes on a hosted runner now fails because the KinD cluster is still in place from the previous run:</p>
<pre><code>% kind create cluster --name e2e
ERROR: failed to create cluster: node(s) already exist for a cluster with the name "e2e"
</code></pre>
<p>So you create a random name for the KinD cluster. Genius! 👩‍🔬</p>
<p>But now your Docker library is full of orphaned KinD clusters and you run out of disk space.</p>
<p>I could go on, but I won't.</p>
<p>Not to mention, this self-hosted runner can only run on job at a time, so you're wasting a lot resources.</p>
<p>When it crashes, you have to duplicate all the work you did to get it running, on another machine.</p>
<p>And you have zero security, no form of isolation, and any job that runs, whether done with malice, or misguided good intent, or an accident can leave the environment compromised.</p>
<h2 id="kubernetes-and-docker-are-secure-and-ephemeral-right">Kubernetes and Docker are secure and ephemeral right?</h2>
<p>Docker is great, Kubernetes is a solid platform, however neither are suited to running CI workloads.</p>
<p>You cannot build, then load an eBPF module into a Kernel using a self-hosted runner in a container.</p>
<p>You cannot safely:</p>
<ul>
<li>run Kubernetes itself in a Kubernetes Pod</li>
<li>build a container image</li>
<li>run a container image you've built.</li>
</ul>
<p>In order to do these things, you have to install Docker into your container/Pod, and start it up. Docker is a daemon that runs as root, and requires host-level privileges in order to do its work.</p>
<p>There are two ways Actions Runtime Controller and GitLab's Kubernetes Controller go about this:</p>
<ol>
<li>
<p>Mounting a Docker Socket.</p>
<p>Docker has to be running on the host for the container or Pod. You expose the socket via a bind-mount into the container.</p>
<p>Any CI job that runs can take over the host, and worse, can probably make privileged calls into the Kubernetes cluster, and exfiltrate any secrets such as cloud access keys.</p>
</li>
<li>
<p>Running as a Privileged container</p>
<p>When you run a Pod as a Privileged container, a separate Docker Daemon starts up. It does not share the daemon with the host, however it gives a false sense of security.</p>
<p>Whilst you now have two docker daemons running, the one running within in your container has to use Virtual Filesystem (VFS) - a slow, and expensive emulated filesystem that is required to support Docker inside Docker.</p>
<p>The Pod itself has a privileged runtime profile, which means: it has unrestricted access to the host's resources, including the ability to manipulate kernel modules, access devices, and interact with sensitive system-level functions. Running with these elevated privileges opens up significant security risks:</p>
<ul>
<li>Host Compromise: Since the container has broad access to the underlying host, it could potentially manipulate the host’s configuration, modify system files, or install malicious software.</li>
<li>Kernel Exploits: If there are any vulnerabilities in the host kernel, a privileged container could exploit them to gain root access to the host.</li>
<li>Device Access: Privileged containers can interact with devices on the host, such as block devices, USB devices, or network interfaces. This can lead to unauthorized access or data leakage.</li>
<li>Increased Attack Surface: Privileged containers can perform actions that are generally prohibited in standard containers, such as changing sysctl parameters or configuring iptables rules, which expands the attack surface.</li>
</ul>
</li>
</ol>
<p>In short, Kubernetes and Docker are not secure for running CI workloads that require anything beyond basic user-space tasks. They lack the isolation and security needed for complex, multi-tenant CI environments.</p>
<h2 id="so-whats-the-alternative">So what's the alternative?</h2>
<p>GitHub emphasizes that their hosted runners run in ephemeral, isolated virtual machines. But when you're managing your own runners on VMs or in Kubernetes, the environment is anything but ephemeral. Jobs can persist malicious code, leak secrets, and compromise the entire system.</p>
<blockquote>
<p>GitHub-hosted runners execute code within ephemeral and clean isolated virtual machines, meaning there is no way to persistently compromise this environment, or otherwise gain access to more information than was placed in this environment during the bootstrap process.</p>
</blockquote>
<blockquote>
<p>Self-hosted runners for GitHub do not have guarantees around running in ephemeral clean virtual machines, and can be persistently compromised by untrusted code in a workflow.</p>
</blockquote>
<p>Some people will start to look for how to run Docker without a Privileged Pod, without a Docker Socket Mount, without root, but all these solutions tend to be half-baked, and still involve using root somewhere along the line. User namespaces have come up a number of times, but are not compatible with every kind of Kernel, and user workload.</p>
<p>There’s no simple workaround here. Tools like Kaniko, Buildah, and BuildKit do exist, but they introduce complexity and, at some point, often require root access or privileged operations—just not where you might expect it. Linux User namespaces were meant to address these issues, but they come with their own set of challenges, like compatibility with certain workloads and kernels, and they aren’t a universal solution.</p>
<p>Each of these tools focuses primarily on building containers, not running them in a secure way. When you need to run Kubernetes, K3s, or even Docker within a CI job, you're effectively back at square one. These tools try to patch up container isolation issues with band-aid fixes, but none of them offer the clean separation and security needed for running truly secure CI jobs.</p>
<p>On top of that, they frustrate the developer experience. Teams want to get things done with familiar tools — most notably, Docker - which they use in local development. By introducing these alternative tools, you add friction, slow down the workflow, and ultimately, you’re still left with a suboptimal security model.</p>
<p>Over two years ago, even as a staunch supporter of Kubernetes, <a href="https://x.com/alexellisuk/status/1573599285362532353">I finally realised</a> that putting a square peg into a round hole was simply not working, and that there was a better way.</p>
<p>Docker containers and Kubernetes Pods can be great for running multi-tenant workload, but this all changes the moment that they need host level privileges. And frankly, anything but trivial CI jobs tend to need a full Operating System.</p>
<p>VMs have a bad rap for being bulky, presenting a large attack surface, expensive to license, difficult to automate, and in the cloud world, slow to boot up.</p>
<p>That's where microVMs come in. Unlike traditional VMs or containers, microVMs:</p>
<ul>
<li>Boot in under a second.</li>
<li>Run from lightweight root filesystems.</li>
<li>Provide true API-driven automation with minimal overhead.</li>
<li>Strip out unnecessary devices and features, focusing only on what's needed to run a job securely.</li>
</ul>
<p>With microVMs, we get the isolation and security benefits of VMs without the bloat. They don’t need UEFI or BIOS, and they limit the attack surface dramatically.</p>
<p>The two best known solutions are:</p>
<ul>
<li><a href="https://github.com/firecracker-microvm/firecracker">Firecracker</a> by the AWS team - focused on short-lived workloads</li>
<li><a href="https://github.com/cloud-hypervisor/cloud-hypervisor">cloud-hypervisor</a> (a fork of Firecracker) with additional support for PCI devices, and long-lived workloads</li>
</ul>
<p>In Summer 2022, I built a prototype to run self-hosted runners with GitHub Actions, and reiterated some of the issues we discussed today. By October, we'd launched a Pilot and ran tens of thousands of securely isolated jobs for our first customer in just a few days.</p>
<blockquote class="twitter-tweet" data-conversation="none" data-theme="dark"><p lang="en" dir="ltr">Enter actuated 🤘<br><br>1) You set up a number of hosts with a bare OS and our agent binary<br>2) We run the control plane and start one-shot microVMs for every job<br>3) We managed the base VM image with all its tools<br>4) We schedule efficiently not to waste money or to exceed resources <a href="https://t.co/Xn2dz77vad">pic.twitter.com/Xn2dz77vad</a></p>&mdash; Alex Ellis (@alexellisuk) <a href="https://twitter.com/alexellisuk/status/1573599294329954304?ref_src=twsrc%5Etfw">September 24, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>I spoke at <a href="https://cloud-native.rejekts.io/">Cloud Native Rejekts</a> just before KubeCon, to staunch Kubernetes users, and got a resounding round of applause. I think something clicked, people realised Kubernetes is a wonderful platform, but we need something different for CI.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/pTQ_jVYhAoc?si=Cb7tZZJa7wf3cDEr" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>There are downsides however. Working with microVMs needs low-level Linux expertise, and I'm not talking about the kind of insights you get from Googling or a ChatGPT session. To make secure and proficient use of them requires a deep understanding of Kernel configurations, how to debug them when something is missing, what makes up a root filesystem, Linux networking, cgroups, and so much more. And that's before you've even started building a <a href="https://docs.actuated.com/dashboard/">UI dashboard</a>, API and integration with a CI system like GitHub or GitLab.</p>
<p>The community support for Firecracker is very limited, since the maintainers are more focused on how AWS uses the technology, than furthering external adoption. For that reason we've have to do a lot of independent R&#x26;D, and leant into my past experience with Linux systems engineering from OpenFaaS, and inlets.</p>
<p>If you'd like to get a flavour of what it's like to run a microVM, you can try out my quick start: <a href="https://actuated.com/blog/firecracker-container-lab">Grab your lab coat - we're building a microVM from a container</a>.</p>
<h2 id="wrapping-up--further-resources">Wrapping up &#x26; further resources</h2>
<p>There are various reasons to consider self-hosted runners: cost optimisation, access to faster hardware, running on Arm hardware for multi-arch builds, and for the fastest possible access to private networks.</p>
<p>If you're considering using a self-hosted runner installed on a VM for an OSS project, just don't. The risks are obvious, and there is no up side. GitHub is very clear about the risks. You may get away with it for a limited time for a closed-source repository, but it is a lot of work keeping up, and coping with side-effects. Is this the secure environment that your customers would expect you to be using?</p>
<p>If you're considering using a Kubernetes-based solution, make sure that you only run tools that are safe like Python, Node, Go, without building or running any containers. You may be OK, if you have set up comprehensive network policies to prevent attacks to the internal network and any cloud metadata services. One of the first thing penetration testers look for is an unsecured cloud metadata endpoint, it can often be used to obtain access keys to your cloud account through IAM roles that are applied to the base host.</p>
<p>When you install GitLab through their helm chart, their warning is clear:</p>
<blockquote>
<p>You've installed GitLab Runner without the ability to use 'docker in docker'.
The GitLab Runner chart (gitlab/gitlab-runner) is deployed without the <code>privileged</code> flag by default for security purposes. This can be changed by setting <code>gitlab-runner.runners.privileged</code> to <code>true</code>. Before doing so, please read the GitLab Runner chart's documentation on why we chose not to enable this by default. See <a href="https://docs.gitlab.com/runner/install/kubernetes.html#running-docker-in-docker-containers-with-gitlab-runners">https://docs.gitlab.com/runner/install/kubernetes.html#running-docker-in-docker-containers-with-gitlab-runners</a></p>
</blockquote>
<p>If you need to run a container, or build one, you really only have two safe options: hosted runners or a solution like actuated.</p>
<p>Hosted runners have come on a long way since we started a couple of years ago, however they are still 2-3x more expensive than actuated at higher volumes. The Arm support is still limited, if you need access to large datasets of LLM models, a VPN is simply too slow, and running a microVM next to the data will be night and day quicker.</p>
<p>If you're interested in trying out actuated, or hearing more, you can get in touch with me and the team here: <a href="https://docs.google.com/forms/d/e/1FAIpQLScA12IGyVFrZtSAp2Oj24OdaSMloqARSwoxx3AZbQbs0wpGww/viewform">Talk to us about Actuated</a></p>
<p>You can also find out more conceptual and technical details about actuated in the <a href="https://docs.actuated.com/faq/">Frequently Asked Questions (FAQ)</a>.</p>
<p>See also:</p>
<ul>
<li><a href="https://actuated.com/blog/actuated-for-gitlab">Secure your GitLab jobs with microVMs and Actuated</a></li>
<li><a href="https://www.youtube.com/watch?v=pTQ_jVYhAoc&#x26;t=1s">Face off: VMs vs. Containers vs Firecracker</a></li>
<li><a href="https://actuated.com/blog/github-actions-usage-cli">Understand your usage of GitHub Actions</a></li>
<li><a href="https://actuated.com/blog/gpus-for-github-actions">Accelerate GitHub Actions with dedicated GPUs</a></li>
</ul></div></div></main><footer class="bg-white"><div class="mx-auto max-w-7xl py-12 px-4 sm:px-6 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-400 hover:text-gray-500" href="https://twitter.com/selfactuated"><span class="sr-only">Twitter</span><svg fill="currentColor" viewBox="0 0 24 24" class="h-6 w-6" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg></a><a class="text-gray-400 hover:text-gray-500" href="https://github.com/self-actuated"><span class="sr-only">GitHub</span><svg fill="currentColor" viewBox="0 0 24 24" class="h-6 w-6" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"></path></svg></a><a class="text-gray-400 hover:text-gray-500" href="/rss.xml"><span class="sr-only">RSS</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-6 w-6" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M12.75 19.5v-.75a7.5 7.5 0 00-7.5-7.5H4.5m0-6.75h.75c7.87 0 14.25 6.38 14.25 14.25v.75M6 18.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0z"></path></svg></a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-base text-gray-400">© 2024 <a href="https://openfaas.com">OpenFaaS Ltd</a>. All rights reserved. <a class="hover:underline" href="/terms">Terms &amp; Conditions.</a></p></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"how-secure-are-containers-vs-microvms-ci","fileName":"2024-10-23-how-secure-are-containers-vs-microvms-ci.md","contentHtml":"\u003cblockquote\u003e\n\u003cp\u003eYou've landed here because you're looking for a secure way to run self-hosted CI runners. Our solution isolates CI jobs in one-shot, ephemeral microVMs, but you might be wondering: Why microVMs? Why not just install a self-hosted runner on a VM or use Kubernetes?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThese are valid questions. If you've never considered the security implications of these setups, take a moment to see why microVMs offer a secure alternative.\u003c/p\u003e\n\u003cp\u003eAs of today, we've processed 4.4 million minutes of CI jobs for commercial and \u003ca href=\"/blog/millions-of-cncf-minutes\"\u003eopen-source CNCF projects\u003c/a\u003e, all running in securely isolated microVMs that boot in under a second and are destroyed immediately after the job completes. Some customers use a pool of servers that we manage as part of the subscription, and others have their own dedicated bare-metal hardware rented from \u003ca href=\"https://docs.actuated.com/provision-server/\"\u003ecloud providers like Hetzner or Equinix\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis article will walk you through the risks of common self-hosted CI solutions and why microVMs are the safest choice.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat does GitHub have to say about self-hosted runner security?\u003c/li\u003e\n\u003cli\u003eThe side effects of an uncontained self-hosted runner\u003c/li\u003e\n\u003cli\u003eKubernetes and Docker are secure and ephemeral right?\u003c/li\u003e\n\u003cli\u003eSo what's the alternative?\u003c/li\u003e\n\u003cli\u003eWrapping up \u0026#x26; further resources\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt's not the first time I've spoken on this topic, you'll find a recording from a conference talk I gave, and a link to the \u003ca href=\"https://actuated.com/blog/blazing-fast-ci-with-microvms\"\u003eoriginal announcement\u003c/a\u003e over two years ago.\u003c/p\u003e\n\u003ch2 id=\"what-does-github-have-to-say-about-self-hosted-runner-security\"\u003eWhat does GitHub have to say about self-hosted runner security?\u003c/h2\u003e\n\u003cp\u003eAccording to \u003ca href=\"https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#self-hosted-runner-security\"\u003eSelf-hosted runner security\u003c/a\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis is not an issue with GitHub-hosted runners because each GitHub-hosted runner is always a clean isolated virtual machine, and it is destroyed at the end of the job execution.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUntrusted workflows running on your self-hosted runner pose significant security risks for your machine and network environment, especially if your machine persists its environment between jobs. Some of the risks include:\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eMalicious programs running on the machine.\u003c/li\u003e\n\u003cli\u003eEscaping the machine's runner sandbox.\u003c/li\u003e\n\u003cli\u003eExposing access to the machine's network environment.\u003c/li\u003e\n\u003cli\u003ePersisting unwanted or dangerous data on the machine.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"the-side-effects-of-an-uncontained-self-hosted-runner\"\u003eThe side effects of an uncontained self-hosted runner\u003c/h2\u003e\n\u003cp\u003eMy earliest memory of the self-hosted runner went a little bit like this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOK that was easy, what is everyone complaining about?\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eRuns my first job\u003c/em\u003e - oh that apt package is missing, let me install it..\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eGoes red again\u003c/em\u003e - oh yeah, better add that too\u003c/li\u003e\n\u003cli\u003eAnd that one\u003c/li\u003e\n\u003cli\u003e50 minutes into the build and something else is missing 🤦‍♂️\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eJust installing all the dependencies into your VM that are in the hosted runner, to get some semblance of parity is an arduous task and an ever moving target.\u003c/p\u003e\n\u003cp\u003eNext, you create a KinD cluster and it goes well for the first run.\u003c/p\u003e\n\u003cp\u003eThe same job that passes on a hosted runner now fails because the KinD cluster is still in place from the previous run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e% kind create cluster --name e2e\nERROR: failed to create cluster: node(s) already exist for a cluster with the name \"e2e\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo you create a random name for the KinD cluster. Genius! 👩‍🔬\u003c/p\u003e\n\u003cp\u003eBut now your Docker library is full of orphaned KinD clusters and you run out of disk space.\u003c/p\u003e\n\u003cp\u003eI could go on, but I won't.\u003c/p\u003e\n\u003cp\u003eNot to mention, this self-hosted runner can only run on job at a time, so you're wasting a lot resources.\u003c/p\u003e\n\u003cp\u003eWhen it crashes, you have to duplicate all the work you did to get it running, on another machine.\u003c/p\u003e\n\u003cp\u003eAnd you have zero security, no form of isolation, and any job that runs, whether done with malice, or misguided good intent, or an accident can leave the environment compromised.\u003c/p\u003e\n\u003ch2 id=\"kubernetes-and-docker-are-secure-and-ephemeral-right\"\u003eKubernetes and Docker are secure and ephemeral right?\u003c/h2\u003e\n\u003cp\u003eDocker is great, Kubernetes is a solid platform, however neither are suited to running CI workloads.\u003c/p\u003e\n\u003cp\u003eYou cannot build, then load an eBPF module into a Kernel using a self-hosted runner in a container.\u003c/p\u003e\n\u003cp\u003eYou cannot safely:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003erun Kubernetes itself in a Kubernetes Pod\u003c/li\u003e\n\u003cli\u003ebuild a container image\u003c/li\u003e\n\u003cli\u003erun a container image you've built.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn order to do these things, you have to install Docker into your container/Pod, and start it up. Docker is a daemon that runs as root, and requires host-level privileges in order to do its work.\u003c/p\u003e\n\u003cp\u003eThere are two ways Actions Runtime Controller and GitLab's Kubernetes Controller go about this:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eMounting a Docker Socket.\u003c/p\u003e\n\u003cp\u003eDocker has to be running on the host for the container or Pod. You expose the socket via a bind-mount into the container.\u003c/p\u003e\n\u003cp\u003eAny CI job that runs can take over the host, and worse, can probably make privileged calls into the Kubernetes cluster, and exfiltrate any secrets such as cloud access keys.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRunning as a Privileged container\u003c/p\u003e\n\u003cp\u003eWhen you run a Pod as a Privileged container, a separate Docker Daemon starts up. It does not share the daemon with the host, however it gives a false sense of security.\u003c/p\u003e\n\u003cp\u003eWhilst you now have two docker daemons running, the one running within in your container has to use Virtual Filesystem (VFS) - a slow, and expensive emulated filesystem that is required to support Docker inside Docker.\u003c/p\u003e\n\u003cp\u003eThe Pod itself has a privileged runtime profile, which means: it has unrestricted access to the host's resources, including the ability to manipulate kernel modules, access devices, and interact with sensitive system-level functions. Running with these elevated privileges opens up significant security risks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHost Compromise: Since the container has broad access to the underlying host, it could potentially manipulate the host’s configuration, modify system files, or install malicious software.\u003c/li\u003e\n\u003cli\u003eKernel Exploits: If there are any vulnerabilities in the host kernel, a privileged container could exploit them to gain root access to the host.\u003c/li\u003e\n\u003cli\u003eDevice Access: Privileged containers can interact with devices on the host, such as block devices, USB devices, or network interfaces. This can lead to unauthorized access or data leakage.\u003c/li\u003e\n\u003cli\u003eIncreased Attack Surface: Privileged containers can perform actions that are generally prohibited in standard containers, such as changing sysctl parameters or configuring iptables rules, which expands the attack surface.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIn short, Kubernetes and Docker are not secure for running CI workloads that require anything beyond basic user-space tasks. They lack the isolation and security needed for complex, multi-tenant CI environments.\u003c/p\u003e\n\u003ch2 id=\"so-whats-the-alternative\"\u003eSo what's the alternative?\u003c/h2\u003e\n\u003cp\u003eGitHub emphasizes that their hosted runners run in ephemeral, isolated virtual machines. But when you're managing your own runners on VMs or in Kubernetes, the environment is anything but ephemeral. Jobs can persist malicious code, leak secrets, and compromise the entire system.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGitHub-hosted runners execute code within ephemeral and clean isolated virtual machines, meaning there is no way to persistently compromise this environment, or otherwise gain access to more information than was placed in this environment during the bootstrap process.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSelf-hosted runners for GitHub do not have guarantees around running in ephemeral clean virtual machines, and can be persistently compromised by untrusted code in a workflow.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSome people will start to look for how to run Docker without a Privileged Pod, without a Docker Socket Mount, without root, but all these solutions tend to be half-baked, and still involve using root somewhere along the line. User namespaces have come up a number of times, but are not compatible with every kind of Kernel, and user workload.\u003c/p\u003e\n\u003cp\u003eThere’s no simple workaround here. Tools like Kaniko, Buildah, and BuildKit do exist, but they introduce complexity and, at some point, often require root access or privileged operations—just not where you might expect it. Linux User namespaces were meant to address these issues, but they come with their own set of challenges, like compatibility with certain workloads and kernels, and they aren’t a universal solution.\u003c/p\u003e\n\u003cp\u003eEach of these tools focuses primarily on building containers, not running them in a secure way. When you need to run Kubernetes, K3s, or even Docker within a CI job, you're effectively back at square one. These tools try to patch up container isolation issues with band-aid fixes, but none of them offer the clean separation and security needed for running truly secure CI jobs.\u003c/p\u003e\n\u003cp\u003eOn top of that, they frustrate the developer experience. Teams want to get things done with familiar tools — most notably, Docker - which they use in local development. By introducing these alternative tools, you add friction, slow down the workflow, and ultimately, you’re still left with a suboptimal security model.\u003c/p\u003e\n\u003cp\u003eOver two years ago, even as a staunch supporter of Kubernetes, \u003ca href=\"https://x.com/alexellisuk/status/1573599285362532353\"\u003eI finally realised\u003c/a\u003e that putting a square peg into a round hole was simply not working, and that there was a better way.\u003c/p\u003e\n\u003cp\u003eDocker containers and Kubernetes Pods can be great for running multi-tenant workload, but this all changes the moment that they need host level privileges. And frankly, anything but trivial CI jobs tend to need a full Operating System.\u003c/p\u003e\n\u003cp\u003eVMs have a bad rap for being bulky, presenting a large attack surface, expensive to license, difficult to automate, and in the cloud world, slow to boot up.\u003c/p\u003e\n\u003cp\u003eThat's where microVMs come in. Unlike traditional VMs or containers, microVMs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBoot in under a second.\u003c/li\u003e\n\u003cli\u003eRun from lightweight root filesystems.\u003c/li\u003e\n\u003cli\u003eProvide true API-driven automation with minimal overhead.\u003c/li\u003e\n\u003cli\u003eStrip out unnecessary devices and features, focusing only on what's needed to run a job securely.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWith microVMs, we get the isolation and security benefits of VMs without the bloat. They don’t need UEFI or BIOS, and they limit the attack surface dramatically.\u003c/p\u003e\n\u003cp\u003eThe two best known solutions are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/firecracker-microvm/firecracker\"\u003eFirecracker\u003c/a\u003e by the AWS team - focused on short-lived workloads\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/cloud-hypervisor/cloud-hypervisor\"\u003ecloud-hypervisor\u003c/a\u003e (a fork of Firecracker) with additional support for PCI devices, and long-lived workloads\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn Summer 2022, I built a prototype to run self-hosted runners with GitHub Actions, and reiterated some of the issues we discussed today. By October, we'd launched a Pilot and ran tens of thousands of securely isolated jobs for our first customer in just a few days.\u003c/p\u003e\n\u003cblockquote class=\"twitter-tweet\" data-conversation=\"none\" data-theme=\"dark\"\u003e\u003cp lang=\"en\" dir=\"ltr\"\u003eEnter actuated 🤘\u003cbr\u003e\u003cbr\u003e1) You set up a number of hosts with a bare OS and our agent binary\u003cbr\u003e2) We run the control plane and start one-shot microVMs for every job\u003cbr\u003e3) We managed the base VM image with all its tools\u003cbr\u003e4) We schedule efficiently not to waste money or to exceed resources \u003ca href=\"https://t.co/Xn2dz77vad\"\u003epic.twitter.com/Xn2dz77vad\u003c/a\u003e\u003c/p\u003e\u0026mdash; Alex Ellis (@alexellisuk) \u003ca href=\"https://twitter.com/alexellisuk/status/1573599294329954304?ref_src=twsrc%5Etfw\"\u003eSeptember 24, 2022\u003c/a\u003e\u003c/blockquote\u003e \u003cscript async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"\u003e\u003c/script\u003e\n\u003cp\u003eI spoke at \u003ca href=\"https://cloud-native.rejekts.io/\"\u003eCloud Native Rejekts\u003c/a\u003e just before KubeCon, to staunch Kubernetes users, and got a resounding round of applause. I think something clicked, people realised Kubernetes is a wonderful platform, but we need something different for CI.\u003c/p\u003e\n\u003ciframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pTQ_jVYhAoc?si=Cb7tZZJa7wf3cDEr\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen\u003e\u003c/iframe\u003e\n\u003cp\u003eThere are downsides however. Working with microVMs needs low-level Linux expertise, and I'm not talking about the kind of insights you get from Googling or a ChatGPT session. To make secure and proficient use of them requires a deep understanding of Kernel configurations, how to debug them when something is missing, what makes up a root filesystem, Linux networking, cgroups, and so much more. And that's before you've even started building a \u003ca href=\"https://docs.actuated.com/dashboard/\"\u003eUI dashboard\u003c/a\u003e, API and integration with a CI system like GitHub or GitLab.\u003c/p\u003e\n\u003cp\u003eThe community support for Firecracker is very limited, since the maintainers are more focused on how AWS uses the technology, than furthering external adoption. For that reason we've have to do a lot of independent R\u0026#x26;D, and leant into my past experience with Linux systems engineering from OpenFaaS, and inlets.\u003c/p\u003e\n\u003cp\u003eIf you'd like to get a flavour of what it's like to run a microVM, you can try out my quick start: \u003ca href=\"https://actuated.com/blog/firecracker-container-lab\"\u003eGrab your lab coat - we're building a microVM from a container\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"wrapping-up--further-resources\"\u003eWrapping up \u0026#x26; further resources\u003c/h2\u003e\n\u003cp\u003eThere are various reasons to consider self-hosted runners: cost optimisation, access to faster hardware, running on Arm hardware for multi-arch builds, and for the fastest possible access to private networks.\u003c/p\u003e\n\u003cp\u003eIf you're considering using a self-hosted runner installed on a VM for an OSS project, just don't. The risks are obvious, and there is no up side. GitHub is very clear about the risks. You may get away with it for a limited time for a closed-source repository, but it is a lot of work keeping up, and coping with side-effects. Is this the secure environment that your customers would expect you to be using?\u003c/p\u003e\n\u003cp\u003eIf you're considering using a Kubernetes-based solution, make sure that you only run tools that are safe like Python, Node, Go, without building or running any containers. You may be OK, if you have set up comprehensive network policies to prevent attacks to the internal network and any cloud metadata services. One of the first thing penetration testers look for is an unsecured cloud metadata endpoint, it can often be used to obtain access keys to your cloud account through IAM roles that are applied to the base host.\u003c/p\u003e\n\u003cp\u003eWhen you install GitLab through their helm chart, their warning is clear:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eYou've installed GitLab Runner without the ability to use 'docker in docker'.\nThe GitLab Runner chart (gitlab/gitlab-runner) is deployed without the \u003ccode\u003eprivileged\u003c/code\u003e flag by default for security purposes. This can be changed by setting \u003ccode\u003egitlab-runner.runners.privileged\u003c/code\u003e to \u003ccode\u003etrue\u003c/code\u003e. Before doing so, please read the GitLab Runner chart's documentation on why we chose not to enable this by default. See \u003ca href=\"https://docs.gitlab.com/runner/install/kubernetes.html#running-docker-in-docker-containers-with-gitlab-runners\"\u003ehttps://docs.gitlab.com/runner/install/kubernetes.html#running-docker-in-docker-containers-with-gitlab-runners\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIf you need to run a container, or build one, you really only have two safe options: hosted runners or a solution like actuated.\u003c/p\u003e\n\u003cp\u003eHosted runners have come on a long way since we started a couple of years ago, however they are still 2-3x more expensive than actuated at higher volumes. The Arm support is still limited, if you need access to large datasets of LLM models, a VPN is simply too slow, and running a microVM next to the data will be night and day quicker.\u003c/p\u003e\n\u003cp\u003eIf you're interested in trying out actuated, or hearing more, you can get in touch with me and the team here: \u003ca href=\"https://docs.google.com/forms/d/e/1FAIpQLScA12IGyVFrZtSAp2Oj24OdaSMloqARSwoxx3AZbQbs0wpGww/viewform\"\u003eTalk to us about Actuated\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eYou can also find out more conceptual and technical details about actuated in the \u003ca href=\"https://docs.actuated.com/faq/\"\u003eFrequently Asked Questions (FAQ)\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eSee also:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://actuated.com/blog/actuated-for-gitlab\"\u003eSecure your GitLab jobs with microVMs and Actuated\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=pTQ_jVYhAoc\u0026#x26;t=1s\"\u003eFace off: VMs vs. Containers vs Firecracker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://actuated.com/blog/github-actions-usage-cli\"\u003eUnderstand your usage of GitHub Actions\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://actuated.com/blog/gpus-for-github-actions\"\u003eAccelerate GitHub Actions with dedicated GPUs\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"How secure are containers \u0026 Kubernetes vs. microVMs for self-hosted CI?","description":"How secure are your self-hosted CI runners? We compare running CI jobs on VMs, containers, and Kubernetes versus one-shot, ephemeral microVMs.","tags":["security","containers","gitlab","kubernetes","multiarch"],"author_img":"alex","image":"/images/2024-10-containers-vs-microvms/background.png","date":"2024-10-23"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"how-secure-are-containers-vs-microvms-ci"},"buildId":"TgOuHhQDJRTA5mcfvYzxs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>