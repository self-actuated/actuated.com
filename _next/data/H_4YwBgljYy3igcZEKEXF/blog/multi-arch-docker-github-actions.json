{"pageProps":{"post":{"slug":"multi-arch-docker-github-actions","fileName":"2023-02-01-multi-arch-docker-github-actions.md","contentHtml":"<p>In 2017, I wrote an article on <a href=\"https://docs.docker.com/build/building/multi-stage/\">multi-stage builds with Docker</a>, and it's now part of the Docker Documentation. In my opinion, multi-arch builds were the proceeding step in the evolution of container images.</p>\n<h2>What's multi-arch and why should you care?</h2>\n<p>If you want users to be able to use your containers on different types of computer, then you'll often need to build different versions of your binaries and containers.</p>\n<p>The <a href=\"https://github.com/openfaas/faas-cli\">faas-cli</a> tool is how users interact with <a href=\"https://github.com/openfaas/faas\">OpenFaaS</a>.</p>\n<p>It's distributed in binary format for users, with builds for Windows, MacOS and Linux.</p>\n<ul>\n<li><code>linux/amd64</code>, <code>linux/arm64</code>, <code>linux/arm/v7</code></li>\n<li><code>darwin/amd64</code>, <code>darwin/arm64</code></li>\n<li><code>windows/amd64</code></li>\n</ul>\n<p>But why are there six different binaries for three Operating Systems? With the advent of Raspberry Pi, M1 Macs (Apple Silicon) and AWS Graviton servers, we have had to start building binaries for more than just Intel systems.</p>\n<p>If you're curious how to build multi-arch binaries with Go, you can check out the release process for the open source arkade tool here, which is a simpler example than faas-cli: <a href=\"https://github.com/alexellis/arkade/blob/master/Makefile\">arkade Makefile</a> and <a href=\"https://github.com/alexellis/arkade/blob/master/.github/workflows/publish.yml\">GitHub Actions publish job</a></p>\n<p>So if we have to support at least six different binaries for Open Source CLIs, what about container images?</p>\n<h2>Do we need multi-arch containers too?</h2>\n<p>Until recently, it was common to hear people say: \"I can't find any containers that work for Arm\". This was because the majority of container images were built only for Intel. Docker Inc has done a sterling job of making their \"official\" images work on different platforms, that's why you can now run <code>docker run -t -i ubuntu /bin/bash</code> on a Raspberry Pi, M1 Mac and your regular PC.</p>\n<p>Many open source projects have also caught on to the need for multi-arch images, but there are still a few like Bitnami, haven't yet seen value. I think that is OK, this kind work does take time and effort. Ultimately, it's up to the project maintainers to listen to their users and decide if they have enough interest to add support for Arm.</p>\n<p>A multi-arch image is a container that will work on two or more different combinations of operating system and CPU architecture.</p>\n<p>Typically, this would be:</p>\n<ul>\n<li><code>linux/amd64</code> - \"normal\" computers made by Intel or AMD</li>\n<li><code>linux/arm64</code> - 64-bit Arm servers like <a href=\"https://docs.aws.amazon.com/whitepapers/latest/aws-graviton-performance-testing/what-is-aws-graviton.html\">AWS Graviton</a> or <a href=\"https://amperecomputing.com/processors/ampere-altra/\">Ampere Altra</a></li>\n<li><code>linux/arm/v7</code> - the 32-bit Raspberry Pi Operating System</li>\n</ul>\n<p>So multi-arch is really about catering for the needs of Arm users. Arm hardware platforms like the Ampere Altra come with 80 efficient CPU cores, have a very low TDP compared to traditional Intel hardware, and are available from various cloud providers.</p>\n<h2>How do we build multi-arch containers work?</h2>\n<p>There are a few tools and tricks that we can combine together to take a single Dockerfile and output an image that anyone can pull, which will be right for their machine.</p>\n<p>Let's take the: <code>ghcr.io/inlets-operator:latest</code> image from <a href=\"https://inlets.dev/\">inlets</a>.</p>\n<p>When a user types in <code>docker pull</code>, or deploys a Pod to Kubernetes, their local containerd daemon will fetch the manifest file and inspect it to see what SHA reference to use for to download the required layers for the image.</p>\n<p><img src=\"/images/2023-02-multi-arch/multi-arch.png\" alt=\"How manifests work\"></p>\n<blockquote>\n<p>How manifests work</p>\n</blockquote>\n<p>Let's look at a manifest file with the crane tool. I'm going to use <a href=\"https://arkade.dev\">arkade</a> to install crane:</p>\n<pre><code class=\"hljs language-bash\">arkade get crane\n\ncrane manifest ghcr.io/inlets/inlets-operator:latest\n</code></pre>\n<p>You'll see a manifests array, with a platform section for each image:</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"mediaType\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"application/vnd.docker.distribution.manifest.list.v2+json\"</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"manifests\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">\"mediaType\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"application/vnd.docker.distribution.manifest.v2+json\"</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">\"digest\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"sha256:bae8025e080d05f1db0e337daae54016ada179152e44613bf3f8c4243ad939df\"</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">\"platform\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"architecture\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"amd64\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"os\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"linux\"</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">\"mediaType\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"application/vnd.docker.distribution.manifest.v2+json\"</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">\"digest\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"sha256:3ddc045e2655f06653fc36ac88d1d85e0f077c111a3d1abf01d05e6bbc79c89f\"</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">\"platform\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"architecture\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"arm64\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"os\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"linux\"</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">]</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h2>How do we convert a Dockerfile to multi-arch?</h2>\n<p>Instead of using the classic version of Docker, we can enable the buildx and Buildkit plugins which provide a way to build multi-arch images.</p>\n<p>We'll continue with the Dockerfile from the open source inlets-operator project.</p>\n<p>Within <a href=\"https://github.com/inlets/inlets-operator/blob/master/Dockerfile\">the Dockerfile</a>, we need to make a couple of changes.</p>\n<pre><code class=\"hljs language-diff\"><span class=\"hljs-deletion\">- FROM golang:1.18 as builder</span>\n<span class=\"hljs-addition\">+ FROM --platform=${BUILDPLATFORM:-linux/amd64} golang:1.18 as builder</span>\n\n<span class=\"hljs-addition\">+ ARG TARGETPLATFORM</span>\n<span class=\"hljs-addition\">+ ARG BUILDPLATFORM</span>\n<span class=\"hljs-addition\">+ ARG TARGETOS</span>\n<span class=\"hljs-addition\">+ ARG TARGETARCH</span>\n</code></pre>\n<p>The BUILDPLATFORM variable is the native architecture and platform of the machine performing the build, this is usually amd64.</p>\n<p>The TARGETPLATFORM is important for the final step of the build, and will normally be injected based upon one each of the platforms you have specified for the build command.</p>\n<p>For Go specifically, we also updated the <code>go build</code> command to tell Go to use cross-compilation based upon the TARGETOS and TARGETARCH environment variables, which are populated by Docker.</p>\n<pre><code class=\"hljs language-diff\"><span class=\"hljs-deletion\">- go build -o inlets-operator</span>\n<span class=\"hljs-addition\">+ GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -o inlets-operator</span>\n</code></pre>\n<p>Here's the full example:</p>\n<pre><code>FROM --platform=${BUILDPLATFORM:-linux/amd64} golang:1.18 as builder\n\nARG TARGETPLATFORM\nARG BUILDPLATFORM\nARG TARGETOS\nARG TARGETARCH\n\nARG Version\nARG GitCommit\n\nENV CGO_ENABLED=0\nENV GO111MODULE=on\n\nWORKDIR /go/src/github.com/inlets/inlets-operator\n\n# Cache the download before continuing\nCOPY go.mod go.mod\nCOPY go.sum go.sum\nRUN go mod download\n\nCOPY .  .\n\nRUN CGO_ENABLED=${CGO_ENABLED} GOOS=${TARGETOS} GOARCH=${TARGETARCH} \\\n  go test -v ./...\n\nRUN CGO_ENABLED=${CGO_ENABLED} GOOS=${TARGETOS} GOARCH=${TARGETARCH} \\\n  go build -ldflags \"-s -w -X github.com/inlets/inlets-operator/pkg/version.Release=${Version} -X github.com/inlets/inlets-operator/pkg/version.SHA=${GitCommit}\" \\\n  -a -installsuffix cgo -o /usr/bin/inlets-operator .\n\nFROM --platform=${BUILDPLATFORM:-linux/amd64} gcr.io/distroless/static:nonroot\n\nLABEL org.opencontainers.image.source=https://github.com/inlets/inlets-operator\n\nWORKDIR /\nCOPY --from=builder /usr/bin/inlets-operator /\nUSER nonroot:nonroot\n\nCMD [\"/inlets-operator\"]\n</code></pre>\n<h2>How to do you configure GitHub Actions to publish multi-arch images?</h2>\n<p>Now that the Dockerfile has been configured, it's time to start working on the GitHub Action.</p>\n<p>This example is taken from the Open Source <a href=\"https://github.com/inlets/inlets-operator\">inlets-operator</a>. It builds a container image containing a Go binary and uses a Dockerfile in the root of the repository.</p>\n<p>View <a href=\"https://github.com/inlets/inlets-operator/blob/master/.github/workflows/publish.yaml\">publish.yaml</a>, adapted for actuated:</p>\n<pre><code class=\"hljs language-diff\">name: publish\n\non:\n  push:\n    tags:\n      - '*'\n\njobs:\n  publish:\n<span class=\"hljs-addition\">+    permissions:</span>\n<span class=\"hljs-addition\">+      packages: write</span>\n\n<span class=\"hljs-deletion\">-   runs-on: ubuntu-latest</span>\n<span class=\"hljs-addition\">+   runs-on: actuated</span>\n    steps:\n      - uses: actions/checkout@master\n        with:\n          fetch-depth: 1\n\n<span class=\"hljs-addition\">+     - name: Setup mirror</span>\n<span class=\"hljs-addition\">+       uses: self-actuated/hub-mirror@master</span>\n      - name: Get TAG\n        id: get_tag\n        run: echo TAG=${GITHUB_REF#refs/tags/} >> $GITHUB_ENV\n      - name: Get Repo Owner\n        id: get_repo_owner\n        run: echo \"REPO_OWNER=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')\" > $GITHUB_ENV\n\n<span class=\"hljs-addition\">+     - name: Set up QEMU</span>\n<span class=\"hljs-addition\">+       uses: docker/setup-qemu-action@v2</span>\n<span class=\"hljs-addition\">+     - name: Set up Docker Buildx</span>\n<span class=\"hljs-addition\">+       uses: docker/setup-buildx-action@v2</span>\n      - name: Login to container Registry\n        uses: docker/login-action@v2\n        with:\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n          registry: ghcr.io\n\n      - name: Release build\n        id: release_build\n        uses: docker/build-push-action@v4\n        with:\n          outputs: \"type=registry,push=true\"\n          provenance: false\n<span class=\"hljs-addition\">+         platforms: linux/amd64,linux/arm/v6,linux/arm64</span>\n          build-args: |\n            Version=${{  env.TAG }}\n            GitCommit=${{ github.sha }}\n          tags: |\n            ghcr.io/${{ env.REPO_OWNER }}/inlets-operator:${{ github.sha }}\n            ghcr.io/${{ env.REPO_OWNER }}/inlets-operator:${{ env.TAG }}\n            ghcr.io/${{ env.REPO_OWNER }}/inlets-operator:latest\n</code></pre>\n<p>All of the images and corresponding manifest are published to GitHub's Container Registry (GHCR). The action itself is able to authenticate to GHCR using a built-in, short-lived token. This is dependent on the \"permissions\" section and \"packages: write\" being set.</p>\n<p>You'll see that we added a <code>Setup mirror</code> step, this explained in the <a href=\"/examples/registry-mirror\">Registry Mirror example</a> and is not required for Hosted Runners.</p>\n<p>The <code>docker/setup-qemu-action@v2</code> step is responsible for setting up QEMU, which is used to emulate the different CPU architectures.</p>\n<p>The <code>docker/build-push-action@v4</code> step is responsible for passing in a number of platform combinations such as: <code>linux/amd64</code> for cloud, <code>linux/arm64</code> for Arm servers and <code>linux/arm/v6</code> for Raspberry Pi.</p>\n<h2>What if you're not using GitHub Actions?</h2>\n<p>The various GitHub Actions published by the Docker team are a great way to get started, but if you look under the hood, they're just syntactic sugar for the Docker CLI.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">export</span> DOCKER_CLI_EXPERIMENTAL=enabled\n\n<span class=\"hljs-comment\"># Have Docker download the latest buildx plugin</span>\ndocker buildx install\n\n<span class=\"hljs-comment\"># Create a buildkit daemon with the name \"multiarch\"</span>\ndocker buildx create \\\n    --use \\\n    --name=multiarch \\\n    --node=multiarch\n\n<span class=\"hljs-comment\"># Install QEMU</span>\ndocker run --<span class=\"hljs-built_in\">rm</span> --privileged \\\n    multiarch/qemu-user-static --reset -p <span class=\"hljs-built_in\">yes</span>\n\n<span class=\"hljs-comment\"># Run a build for the different platforms</span>\ndocker buildx build \\\n    --platform=linux/arm64,linux/amd64 \\\n    --output=<span class=\"hljs-built_in\">type</span>=registry,push=<span class=\"hljs-literal\">true</span> --tag image:tag .\n</code></pre>\n<p>For OpenFaaS users, we do all of the above any time you type in <code>faas-cli publish</code> and the <code>faas-cli build</code> command just runs a regular Docker build, without any of the multi-arch steps.</p>\n<p>If you're interested, you can checkout the code here: <a href=\"https://github.com/openfaas/faas-cli/blob/master/commands/publish.go\">publish.go</a>.</p>\n<h2>Putting it all together</h2>\n<ul>\n<li>CLIs are published for many different combinations of OS and CPU, but containers are usually only required for Linux with an amd64 or Arm CPU.</li>\n<li>Multi-arch images work through a manifest, which then tells containerd which image is needs for the platform it is running on.</li>\n<li>QEMU is a tool for emulating different CPU architectures, and is used to build the images for the different platforms.</li>\n</ul>\n<p>In our experience with OpenFaaS, inlets and actuated, once you have converted one or two projects to build multi-arch images, it becomes a lot easier to do it again, and make all software available for Arm servers.</p>\n<p>You can learn more about <a href=\"https://docs.docker.com/build/building/multi-platform/\">Multi-platform images</a> in the Docker Documentation.</p>\n<p><em>Want more multi-arch examples?</em></p>\n<p>OpenFaaS uses multi-arch Dockerfiles for all of its templates, and the examples are freely available on GitHub including Python, Node, Java and Go.</p>\n<p>See also: <a href=\"https://github.com/openfaas/templates\">OpenFaaS templates</a></p>\n<p><em>A word of caution</em></p>\n<p>QEMU can be incredibly slow at times when using a hosted runner, where a build takes takes 1-2 minutes can extend to over half an hour. If you do run into that, one option is to check out actuated or another solution, which can build directly on an Arm server with a securely isolated Virtual Machine.</p>\n<p>In <a href=\"https://actuated.dev/blog/native-arm64-for-github-actions\">How to make GitHub Actions 22x faster with bare-metal Arm</a>, we showed how we decreased the build time of an open-source Go project from 30.5 mins to 1.5 mins. If this is the direction you go in, you can use a <a href=\"https://docs.actuated.dev/examples/matrix/\">matrix-build</a> instead of a QEMU-based multi-arch build.</p>\n<p>See also: <a href=\"https://docs.actuated.dev/provision-server/#arm64-aka-aarch64\">Recommended bare-metal Arm servers</a></p>","title":"The efficient way to publish multi-arch containers from GitHub Actions","description":"Learn how to publish container images for both Arm and Intel machines from GitHub Actions.","author":"Alex Ellis","tags":["security","oss","multiarch"],"author_img":"alex","image":"/images/2023-02-multi-arch/architecture.jpg","date":"2023-02-01"}},"__N_SSG":true}