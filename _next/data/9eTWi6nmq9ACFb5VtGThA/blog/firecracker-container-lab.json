{"pageProps":{"post":{"slug":"firecracker-container-lab","fileName":"2023-09-05-firecracker-container-lab.md","contentHtml":"<p>When I started learning <a href=\"https://github.com/firecracker-microvm/firecracker\">Firecracker</a>, I ran into frustration after frustration with broken tutorials that were popular in their day, but just hadn't been kept up to date. Almost nothing worked, or was far too complex for the level of interest I had at the time. Most recently, one of the Firecracker maintainers in an effort to make the quickstart better, made it even harder to use. (You can still get a copy of the <a href=\"https://actuated.dev/blog/kvm-in-github-actions\">original Firecracker quickstart in our tutorial on nested virtualisation</a>)</p>\n<p>So I wrote a lab that takes a container image and converts it to a microVM. You'll get your hands dirty, you'll run a microVM, you'll be able to use <code>curl</code> and <code>ssh</code>, even expose a HTTP server to the Internet via inlets, if (like me), you find that kind of thing fun.</p>\n<p>Why would you want to explore Firecracker? A friend of mine, <a href=\"https://iximiuz.com/en/about/\">Ivan Velichko</a> is a prolific writer on containers, and Docker. He is one of the biggest independent evangelists for containers and Kubernetes that I know.</p>\n<p>So when he wanted to build an <a href=\"https://labs.iximiuz.com/\">online labs and training environment</a>, why did he pick Firecracker instead? Simply put, he told that containers don't cut it. He needed something that would mirror the type of machine that you'd encounter in production, when you provision an EC2 instance or a GCP VM. Running Docker, Kubernetes, and performing are hard to do securely within a container, and he knew that was important for his students.</p>\n<p>For us - we had very similar reasons for picking Firecracker for a secure CI solution. Too often the security issues around running privileged containers, and the slow speed of <a href=\"https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/\">Docker In Docker's (DIND)</a> Virtual Filesystem Driver (VFS), are ignored. Heads are put into the sand. We couldn't do that and <a href=\"https://actuated.dev/blog/blazing-fast-ci-with-microvms\">developed actuated.dev</a> as a result. Since we launched the pilot, we've now run over 110k VMs for customer CI jobs on GitHub Actions, and have a <a href=\"https://actuated.dev/blog/secure-microvm-ci-gitlab\">tech preview for GitLab CI</a> where a job can be running within 1 second of pushing a \"commit\".</p>\n<p>So let's get that microVM running for you?</p>\n<h2>How it works ðŸ”¬</h2>\n<p>How to build a microVM from a container</p>\n<p><img src=\"/images/2023-09-firecracker-lab/conceptual.png\" alt=\"/images/2023-09-firecracker-lab/conceptual.png\"></p>\n<blockquote>\n<p>Conceptual archicture of the lab</p>\n</blockquote>\n<p>Here's what we'll be doing:</p>\n<ul>\n<li>Build a root-filesystem from a container image from the Docker Hub</li>\n<li>Download a pre-built Linux Kernel from the Firecracker team</li>\n<li>Build an init system written in Go</li>\n<li>Build a disk image with the init system and root-filesystem</li>\n<li>Configure a networking tap device and IP masquerading</li>\n<li>Start a Firecracker process in the background</li>\n<li>Configure the Firecracker process via curl statements to a UNIX socket</li>\n<li>Finally, issue a boot command and try it out</li>\n</ul>\n<p>Let's look at why we need a init, instead of just running the entrypoint of a container.</p>\n<p>Whilst in theory, you can start a microVM where the first process (PID 1) is your workload, in the same way as Docker, it will leave you with a system which is not properly initialised with things like a /proc/ filesystem, tempfs, hostname, and other things that you'd expect to find in a Linux system.</p>\n<p>For that reason, you'll need to either install systemd into the container image you want to use, or build your own basic init system, which sets up the machine, then starts your workload.</p>\n<p>We're doing the later here.</p>\n<p>In the below program, you'll see key devices and files mounted, to make a functional system. The hostname is then set by using a syscall, and finally <code>/bin/sh</code> is started. You could also start a specific binary, or build an agent into the init for Remote Procedure Calls (RPC) to start and stop your workload, and to query metrics.</p>\n<p>The team at <a href=\"https://fly.io\">Fly.io</a> built their own init and agent combined, and opened-sourced a very early version: <a href=\"https://github.com/superfly/init-snapshot\">github.com/superfly/init-snapshot</a>.</p>\n<p>You'll find my init in: <code>./init/main.go</code>:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// Copyright Alex Ellis 2023</span>\n\n<span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"fmt\"</span>\n\t<span class=\"hljs-string\">\"log\"</span>\n\t<span class=\"hljs-string\">\"os\"</span>\n\t<span class=\"hljs-string\">\"os/exec\"</span>\n\n\t<span class=\"hljs-string\">\"syscall\"</span>\n)\n\n<span class=\"hljs-keyword\">const</span> paths = <span class=\"hljs-string\">\"PATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin\"</span>\n\n<span class=\"hljs-comment\">// main starts an init process that can prepare an environment and start a shell</span>\n<span class=\"hljs-comment\">// after the Kernel has started.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tfmt.Printf(<span class=\"hljs-string\">\"Lab init booting\\nCopyright Alex Ellis 2022, OpenFaaS Ltd\\n\"</span>)\n\n\tmount(<span class=\"hljs-string\">\"none\"</span>, <span class=\"hljs-string\">\"/proc\"</span>, <span class=\"hljs-string\">\"proc\"</span>, <span class=\"hljs-number\">0</span>)\n\tmount(<span class=\"hljs-string\">\"none\"</span>, <span class=\"hljs-string\">\"/dev/pts\"</span>, <span class=\"hljs-string\">\"devpts\"</span>, <span class=\"hljs-number\">0</span>)\n\tmount(<span class=\"hljs-string\">\"none\"</span>, <span class=\"hljs-string\">\"/dev/mqueue\"</span>, <span class=\"hljs-string\">\"mqueue\"</span>, <span class=\"hljs-number\">0</span>)\n\tmount(<span class=\"hljs-string\">\"none\"</span>, <span class=\"hljs-string\">\"/dev/shm\"</span>, <span class=\"hljs-string\">\"tmpfs\"</span>, <span class=\"hljs-number\">0</span>)\n\tmount(<span class=\"hljs-string\">\"none\"</span>, <span class=\"hljs-string\">\"/sys\"</span>, <span class=\"hljs-string\">\"sysfs\"</span>, <span class=\"hljs-number\">0</span>)\n\tmount(<span class=\"hljs-string\">\"none\"</span>, <span class=\"hljs-string\">\"/sys/fs/cgroup\"</span>, <span class=\"hljs-string\">\"cgroup\"</span>, <span class=\"hljs-number\">0</span>)\n\n\tsetHostname(<span class=\"hljs-string\">\"lab-vm\"</span>)\n\n\tfmt.Printf(<span class=\"hljs-string\">\"Lab starting /bin/sh\\n\"</span>)\n\n\tcmd := exec.Command(<span class=\"hljs-string\">\"/bin/sh\"</span>)\n\n\tcmd.Env = <span class=\"hljs-built_in\">append</span>(cmd.Env, paths)\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\terr := cmd.Start()\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-built_in\">panic</span>(fmt.Sprintf(<span class=\"hljs-string\">\"could not start /bin/sh, error: %s\"</span>, err))\n\t}\n\n\terr = cmd.Wait()\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-built_in\">panic</span>(fmt.Sprintf(<span class=\"hljs-string\">\"could not wait for /bin/sh, error: %s\"</span>, err))\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">setHostname</span><span class=\"hljs-params\">(hostname <span class=\"hljs-type\">string</span>)</span></span> {\n\terr := syscall.Sethostname([]<span class=\"hljs-type\">byte</span>(hostname))\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-built_in\">panic</span>(fmt.Sprintf(<span class=\"hljs-string\">\"cannot set hostname to %s, error: %s\"</span>, hostname, err))\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">mount</span><span class=\"hljs-params\">(source, target, filesystemtype <span class=\"hljs-type\">string</span>, flags <span class=\"hljs-type\">uintptr</span>)</span></span> {\n\n\t<span class=\"hljs-keyword\">if</span> _, err := os.Stat(target); os.IsNotExist(err) {\n\t\terr := os.MkdirAll(target, <span class=\"hljs-number\">0755</span>)\n\t\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t\t<span class=\"hljs-built_in\">panic</span>(fmt.Sprintf(<span class=\"hljs-string\">\"error creating target folder: %s %s\"</span>, target, err))\n\t\t}\n\t}\n\n\terr := syscall.Mount(source, target, filesystemtype, flags, <span class=\"hljs-string\">\"\"</span>)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tlog.Printf(<span class=\"hljs-string\">\"%s\"</span>, fmt.Errorf(<span class=\"hljs-string\">\"error mounting %s to %s, error: %s\"</span>, source, target, err))\n\t}\n}\n</code></pre>\n<h2>What you'll need</h2>\n<p><a href=\"https://github.com/firecracker-microvm/firecracker\">Firecracker</a> is a Virtual Machine Monitor (VMM) that leans on Linux's KVM functionality to run VMs. Its beauty is in its simplicity, however even though it doesn't need a lot, you will need KVM to be available. If you have a bare-metal machine, like your own PC, or an old server or laptop, you're all set. There's also plenty of options for bare-metal in the cloud - billed either on a per minute/hour basis or per month.</p>\n<p>And finally, for quick testing, <a href=\"https://m.do.co/c/8d4e75e9886f\">DigitalOcean</a>, GCP, and Azure all support what is known as \"Nested Virtualization\". That's where you obtain a VM, which itself can start further VMs, it's not as fast as bare-metal, but it's cheap and works.</p>\n<p>Finally, whilst Firecracker and actuated (our CI product) both support Arm, and Raspberry Pi, this tutorial is only available for `x86_64`` to keep the instructions simple.</p>\n<h2>Provision the machine</h2>\n<p>I'd recommend you use Ubuntu 22.04, so that you can copy and paste instructions from this tutorial.</p>\n<p>Install Docker CE</p>\n<pre><code class=\"hljs language-bash\">curl -fsSL https://get.docker.com  | sudo sh\n</code></pre>\n<p>Docker will be used to fetch an initial Operating System, to build the init system, and to customise the root filesystem.</p>\n<p>Install arkade, which gives you an easy way to install Firecracker:</p>\n<pre><code class=\"hljs language-bash\">curl -sLS https://get.arkade.dev | sudo sh\n</code></pre>\n<p>Install Firecracker:</p>\n<pre><code class=\"hljs language-bash\">sudo arkade system install firecracker\n</code></pre>\n<h2>Clone the lab</h2>\n<p>Clone the lab onto the machine:</p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/alexellis/firecracker-init-lab --depth=1\n\n<span class=\"hljs-built_in\">cd</span> firecracker-init-lab\n</code></pre>\n<h3>Update the networking script</h3>\n<p>Find out what the primary interface is on the machine using <code>ip addr</code> or <code>ifconfig</code>.</p>\n<p>Edit <code>./setup-networking.sh</code>:</p>\n<pre><code>IFNAME=enp8s0\n</code></pre>\n<p>The script will configure a TAP device which bridges microVMs to your host, then sets up IP forwarding and masquerading so that the microVMs can access the Internet.</p>\n<p>Run <code>./setup-networking.sh</code> to setup the TAP device.</p>\n<h3>Download the Kernel</h3>\n<p>Add <code>make</code> via <code>build-essential</code>:</p>\n<pre><code class=\"hljs language-bash\">sudo apt update &#x26;&#x26; sudo apt install -y build-essential\n</code></pre>\n<p>Run <code>make kernel</code> to download the quickstart Kernel made available by the Firecracker team. Of course, you can build your own, but bear in mind that Firecracker does not have PCI support, so many of the ones you'll find on the Internet will not be appropriate.</p>\n<p>This Makefile target will not actually build a new Kernel, but wil download one that the Firecracker team have pre-built and uploaded to S3.</p>\n<h3>Make the container image</h3>\n<p>Here's the Dockerfile we'll use to build the init system in a multi-stage build, then derive from Alpine Linux for the runtime, this could of course be anything like Ubuntu 22.04, Python, or Node.</p>\n<p><code>./Dockerfile</code>:</p>\n<pre><code>FROM golang:1.20-alpine as build\n\nWORKDIR /go/src/github.com/alexellis/firecracker-init-lab/init\n\nCOPY init .\n\nRUN go build --tags netgo --ldflags '-s -w -extldflags \"-lm -lstdc++ -static\"' -o init main.go\n\nFROM alpine:3.18 as runtime\n\nRUN apk add --no-cache curl ca-certificates htop\n\nCOPY --from=build /go/src/github.com/alexellis/firecracker-init-lab/init/init /init\n</code></pre>\n<p>I've added in a few extra packages to play with.</p>\n<p>Run <code>make root</code>, and you'll see an image in your library:</p>\n<pre><code>docker images | grep alexellis2/custom-init\n\nREPOSITORY                                                          TAG                                                                      IMAGE ID       CREATED         SIZE\nalexellis2/custom-init                                              latest                                                                   f89aa7f3dd27   20 hours ago    13.7MB\n</code></pre>\n<h3>Build the disk image</h3>\n<p>Firecracker needs a disk image, or an exist block device as its boot drive. You can make this dynamically as required, run <code>make extract</code> to extract the container image into the local filesystem as <code>rootfs.tar</code>.</p>\n<p>This step uses <code>docker create</code> followed by <code>docker export</code> to create a temporary container, and then to save its filesystem contents into a tar file.</p>\n<p>Run <code>make extract</code></p>\n<p>If you want to see what a filesystem looks like, you could extract <code>rootfs.tar</code> into <code>/tmp</code> and have a poke around. This is not a required step.</p>\n<p>Then run <code>make image</code>.</p>\n<p>Here, a loopback file allocated with 5GB, then formatted as ext4, under the name <code>rootfs.img</code>. The script mounts the drive and then extracts the contents of the <code>rootfs.tar</code> file into it before unmounting the file.</p>\n<h3>Start a Firecracker process</h3>\n<p>Now, this may feel a little odd or different to Docker users. For each Firecracker VM you want to launch, you'll need to start a process, configure it via curl over a UNIX socket, then issue a boot command.</p>\n<p>To run multiple Firecracker microVMs at once, configure a different socket path for each.</p>\n<pre><code>make start\n</code></pre>\n<h3>Boot the microVM</h3>\n<p>In another window, issue the boot command:</p>\n<pre><code>make boot\n</code></pre>\n<h3>Explore the system</h3>\n<p>You're now booted into a serial console, this isn't a fully functional TTY, so some things won't work, and is really designed for boot-up information, not interactive use. For proper remote administration, you should install an OpenSSH server and then connect to the VM using its IP address.</p>\n<p>That said, you can now explore a little.</p>\n<p>Add a DNS server to <code>/etc/resolv.conf</code>:</p>\n<pre><code>echo \"nameserver 8.8.8.8\" > /etc/resolv.conf\n</code></pre>\n<p>Then try to reach the Internet:</p>\n<pre><code class=\"hljs language-bash\">ping -c 1 8.8.8.8\n\nping -c 4 google.com\n\ncurl --connect-timeout 1 -4 -i https://inlets.dev\n</code></pre>\n<p>Check out the system specifications:</p>\n<pre><code>free -m\ncat /proc/cpuinfo\nip addr\nip route\n</code></pre>\n<p>Add the htop package and try it out:</p>\n<pre><code>apk add --no-cache htop\n\nhtop\n</code></pre>\n<p>I had no issues with masquerading on Equinix Metal or on my own hardware, however on DigitalOcean I saw pings working, but HTTPs failed. You could try changing the MTU to a lower value than 1500: <code>ifconfig eth0 mtu 1300</code>, or turn off IPv6: <code>sysctl -w net.ipv6.conf.all.disable_ipv6=1 &#x26;&#x26; sysctl -w net.ipv6.conf.default.disable_ipv6=1</code>.</p>\n<p>When you're done, kill the firecracker process with <code>sudo killall firecracker</code>, or type in <code>halt</code> to the serial console.</p>\n<h2>Wrapping up</h2>\n<p>I was frustrated by the lack of a simple guide for tinkering with Firecracker, and so that's why I wrote this lab and am keeping it up to date.</p>\n<p>For production use, you could use a HTTP client to make the API requests to the UNIX socket, or an SDK, which abstracts away some of the complexity. There's an <a href=\"https://github.com/firecracker-microvm/firecracker-go-sdk\">official SDK for Go</a> and several <a href=\"https://lib.rs/crates/firec\">unofficial ones for Rust</a>. If you look at the sample code for either, you'll see that they are doing the same things we did in the lab, so you should find it relatively easy to convert the lab to use an SDK instead.</p>\n<p>Did you enjoy the lab? Have you got a use-case for Firecracker? Let me know on Twitter <a href=\"https://x.com/alexellisuk\">@alexellisuk</a></p>\n<p>If you'd like to see how we've applied Firecracker to bring fast and secure CI to teams, check out our product <a href=\"https://actuated.dev/\">actuated.dev</a></p>\n<p>Here's a quick demo of our control-plane, scheduler and bare-metal agent in action:</p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/2o28iUC-J1w?si=xAt7YG4YCJ_ZleCA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>","title":"Grab your lab coat - we're building a microVM from a container","description":"No more broken tutorials, build a microVM from a container, boot it, access the Internet","tags":["firecracker","lab","tutorial"],"author_img":"alex","image":"/images/2023-09-firecracker-lab/background.png","date":"2023-09-05"}},"__N_SSG":true}