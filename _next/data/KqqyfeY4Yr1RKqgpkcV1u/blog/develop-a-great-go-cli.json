{"pageProps":{"post":{"slug":"develop-a-great-go-cli","fileName":"2023-08-22-develop-a-great-go-cli.md","contentHtml":"<p>Is your project's CLI growing with you? I'll cover some of the lessons learned writing the OpenFaaS, actuated, actions-usage, arkade and k3sup CLIs, going as far back as 2016. I hope you'll find some ideas or inspiration for your own projects - either to start them off, or to improve them as you go along.</p>\n<blockquote>\n<p>Just starting your journey, or want to go deeper?</p>\n<p>You can master the fundamentals of Go (also called Golang) with my <a href=\"https://store.openfaas.com/l/everyday-golang\">eBook Everyday Golang</a>, which includes chapters on Go routines, HTTP clients and servers, text templates, unit testing and crafting a CLI. If you're on a budget, I would recommend checkout out the official <a href=\"https://go.dev/tour/\">Go tour</a>, too.</p>\n</blockquote>\n<h2 id=\"introduction\">Introduction</h2>\n<p>The earliest CLI I wrote was for OpenFaaS, called <a href=\"https://github.com/openfaas/faas-cli\">faas-cli</a>. It's a client for a REST API exposed over HTTP, and I remember how it felt to add the first command <em>list functions</em>, then one more, and one more, until it was a fully working CLI with a dozen commands.</p>\n<p>But it started with one command - something that was useful to us at the time, that was to list the available functions.</p>\n<p>The initial version used Go's built-in flags parser, which is rudimentary, but perfectly functional.</p>\n<pre><code>faas-cli -list\nfaas-cli -describe\nfaas-cli -deploy\n</code></pre>\n<p>Over time, you may outgrow this simple approach, and drift towards wanting sub-commands, each with their own set of options.</p>\n<p>An early contributor <a href=\"https://github.com/johnmccabe\">John McCabe</a> introduced me to <a href=\"https://github.com/spf13/cobra\">Cobra</a> and asked if he could convert everything over.</p>\n<pre><code>faas-cli list\nfaas-cli describe\nfaas-cli deploy\n</code></pre>\n<p>Now each sub-command can have its set of flags, and even sub-commands in the case of <code>faas-cli secret list/create/delete</code></p>\n<p><a href=\"https://github.com/self-actuated/actions-usage\">actions-usage</a> is a free analytics tool we wrote for GitHub Actions users to iterate GitHub's API and summarise your usage over a certain period of time. It's also written in Go, but because it's mostly single-purpose, it'll probably never need sub-commands.</p>\n<pre><code>actions-usage -days 28 \\\n    -token-file ~/pat.txt \\\n    -org openfaasltd\n</code></pre>\n<p>Shortly after launching the tool for teams an open-source organisations, we had a feature request to run it on individual user accounts.</p>\n<p>That meant switching up some API calls and adding new CLI flags:</p>\n<pre><code>actions-usage -days 7 \\\n    -token-file ~/pat.txt \\\n    -user alexellis\n</code></pre>\n<p>We then got a bit clever and started adding some extra reports and details, you can see what it looks in the article <a href=\"/blog/github-actions-usage-cli\">Understand your usage of GitHub Actions</a></p>\n<h2 id=\"whats-new-for-actuated-cli\">What's new for actuated-cli</h2>\n<p>I'm very much a believer in a Minimal Viable Product (MVP). If you can create some value or utility to users, you should ship it as early as possible, especially if you have a good feedback loop with them.</p>\n<p>A quick note about the <a href=\"https://github.com/self-actuated/actuated-cli\">actuated-cli</a>, it's main use-cases are to:</p>\n<ul>\n<li>List the runners for an organisation</li>\n<li>List the queued or in-progress jobs for an organisation</li>\n<li>Update a remote server, or get the logs from a VM or the agent service</li>\n</ul>\n<h3 id=\"no-more-owner-flags\">No more owner flags</h3>\n<p>The <code>actuated-cli</code> was designed to work on a certain organisation, but it meant extra typing, so wherever possible, we've removed the flag completely.</p>\n<pre><code>actuated-cli runners --owner openfaasltd\n</code></pre>\n<p>becomes:</p>\n<pre><code>actuated-cli runners\n</code></pre>\n<p>How did we do this? We determine the intersection of organisations for which your account is authorized, and which are enrolled for actuated. It's much less typing and it's more intuitive.</p>\n<h3 id=\"the-host-flag-became-a-positional-argument\">The host flag became a positional argument</h3>\n<p>This was another exercise in reducing typing. Let's say we wanted to upgrade the agent for a certain host, we'd have to type:</p>\n<pre><code>actuated-cli upgrade --owner openfaasltd --host server-1\n</code></pre>\n<p>By looking at the \"args\" slice, instead of for a specific command, we can assume that any text after the flags is always the server name:</p>\n<pre><code>actuated-cli upgrade --owner openfaasltd server-1\n</code></pre>\n<h3 id=\"token-management\">Token management</h3>\n<p>The actuated CLI uses a GitHub personal access token to authenticate with the API. This is a common pattern, but it's not always clear how to manage the token.</p>\n<p>We took inspiration from the <code>gh</code> CLI, which is a wrapper around the GitHub API.</p>\n<p>The <code>gh</code> CLI has a <code>gh auth</code> command which can be used to obtain a token, and save it to a local file, then any future usage of the CLI will use that token.</p>\n<p>Before, you had to create a Personal Access Token in the GitHub UI, then copy and paste it into a file, and decide where to put it, and what to name it. What's more, if you missed a permission, then the token wouldn't work.</p>\n<pre><code>actuated-cli --token ~/pat.txt\n</code></pre>\n<p>Now, you simply run:</p>\n<pre><code>actuated-cli auth\n</code></pre>\n<p>And as you saw from the previous commands, there's no longer any need for the <code>--token</code> flag. Unless of course, you want to supply it, then you can.</p>\n<p>A good way to have a default for a flag, and then an override, is to use the Cobra package's <code>Changed()</code> function. Read the default, unless <code>.Changed()</code> on the <code>--token</code> or <code>--token-value</code> flags return <code>true</code>.</p>\n<h3 id=\"the---json-flag\">The <code>--json</code> flag</h3>\n<p>From early on, I knew that I would want to be able to pipe output into .jq, or perhaps even do some scripting. I've seen this in <code>docker</code>, <code>kubectl</code> and numerous other CLI tools written in Go.</p>\n<pre><code>actuated-cli runners --json | jq '.[] | .name'\n\n\"m1m1\"\n\"m1m2\"\n\"of-epyc-lon1\"\n</code></pre>\n<p>The JSON format also allows you to get access to certain fields which the API call returns, which may not be printed by the default command's text-based formatter:</p>\n<pre><code>|         NAME         |  CUSTOMER   |   STATUS    | VMS  | PING  |   UP    | CPUS |   RAM   | FREE RAM | ARCH  |                 VERSION                  |\n|----------------------|-------------|-------------|------|-------|---------|------|---------|----------|-------|------------------------------------------|\n| of-epyc-lon1         | openfaasltd | running     | 0/5  | 7ms   | 6 days  |   48 | 65.42GB | 62.85GB  | amd64 | 5f702001a952e496a9873d2e37643bdf4a91c229 |\n</code></pre>\n<p>Instead, we get:</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">[</span>  <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">\"name\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"of-epyc-lon1\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"customer\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"openfaasltd\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"pingNano\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">30994998</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"uptimeNano\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">579599000000000</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"cpus\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">48</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"memory\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">65423184000</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"memoryAvailable\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">62852432000</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"vms\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">0</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"maxVms\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">5</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"reachable\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"status\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"running\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"agentSHA\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"5f702001a952e496a9873d2e37643bdf4a91c229\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"arch\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"amd64\"</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">]</span>\n</code></pre>\n<h3 id=\"ssh-commands-and-doing-the-right-thing\">SSH commands and doing the right thing</h3>\n<p>Actuated has a <a href=\"https://docs.actuated.com/tasks/debug-ssh/\">built-in SSH gateway</a>, this means that any job can be debugged - whether running on a hosted or self-hosted runner, just by editing the workflow YAML.</p>\n<p>Add the following to the <code>- steps:</code> section, and the <code>id_token: write</code> permission, and your workflow will pause, and then you can connect over SSH using the CLI or the UI.</p>\n<pre><code class=\"hljs language-yaml\">    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">self-actuated/connect-ssh@master</span>\n</code></pre>\n<p>There are two sub-commands:</p>\n<ul>\n<li><code>actuated-cli ssh list</code> - list the available SSH sessions</li>\n<li><code>actuated-cli ssh connect</code> - connect to an available session</li>\n</ul>\n<p>Here's an example of having only one connection:</p>\n<pre><code>actuated-cli ssh list\n| NO  |   ACTOR   |   HOSTNAME    | RX | TX | CONNECTED |\n|-----|-----------|---------------|----|----|-----------|\n|   1 | alexellis | fv-az1125-168 |  0 |  0 | 32s       |\n</code></pre>\n<p>Now how do you think the <code>ssh connect</code> command should work?</p>\n<p>Here's the most obvious way:</p>\n<pre><code>actuated-cli ssh connect --hostname fv-az1125-168\n</code></pre>\n<p>This is a little obtuse, since we only have one server to connect to, we can improve it for the user, with:</p>\n<pre><code>actuated-cli ssh connect\n</code></pre>\n<p>That's right, we do the right thing, the obvious thing.</p>\n<p>Then when there is more than one connection, instead of adding two flags <code>--no</code> or <code>--hostname</code>, we can simply take the positional argument:</p>\n<pre><code>actuated-cli ssh connect 1\nactuated-cli ssh connect fv-az1125-168\n</code></pre>\n<p>Are there any places where you could simplify your own CLI?</p>\n<p>Read the source code here: <a href=\"https://github.com/self-actuated/actuated-cli/blob/master/cmd/ssh_connect.go\">ssh_connect.go</a></p>\n<h3 id=\"the---verbose-flag\">The <code>--verbose</code> flag</h3>\n<p>We haven't made any use of the <code>--verbose</code> flag yet in the CLI, but it's a common pattern which has been used in <code>faas-cli</code> and various others. Once your output gets to a certain width, it can be hard to view in a terminal, like the output from the previous command.</p>\n<p>To implement <code>--verbose</code>, you should reduce the columns to the absolute minimum to be useful, so maybe we could give up the Version, customer, ping, and CPUs columns in the standard view, then add them back in with <code>--verbose</code>.</p>\n<h3 id=\"table-printing\">Table printing</h3>\n<p>As you can see from the output of the commands above, we make heavy usage of a table printer.</p>\n<p>You don't necessarily need a 3rd-party table printer, Go has a fairly good \"tab writer\" which can create nicely formatted code:</p>\n<pre><code>faas-cli list -g https://openfaas.example.com\nFunction                        Invocations     Replicas\nbcrypt                          9               1    \nfiglet                          0               1    \ninception                       0               1    \nnodeinfo                        2               1    \nping-url                        0               1  \n</code></pre>\n<p>You can find the standard <a href=\"https://pkg.go.dev/text/tabwriter\">tabwriter package</a> here.</p>\n<p>Or try out the <a href=\"https://github.com/olekukonko/tablewriter\">tablewriter</a> package by Olekukonko. We've been able to make use of it in <a href=\"https://arkade.dev\">arkade</a> too - a free marketplace for developer tools.</p>\n<p>See usage in arkade here: <a href=\"https://github.com/alexellis/arkade/blob/master/pkg/get/table.go#L19\">table.go</a></p>\n<p>See usage in actuated-cli's SSH command here: <a href=\"https://github.com/self-actuated/actuated-cli/blob/master/cmd/ssh_ls.go\">ssh_ls.go</a></p>\n<h2 id=\"progress-bars\">Progress bars</h2>\n<p>One thing that has been great about having open-source CLIs, is that other people make suggestions and help you learn about new patterns.</p>\n<p>For arkade, <a href=\"https://twitter.com/rberrelleza\">Ramiro from Okteto</a> sent a PR to add a progress bar to show how long remained to download a big binary like the Kubernetes CLI.</p>\n<pre><code class=\"hljs language-bash\">arkade get kubectl\nDownloading: kubectl\nDownloading: https://storage.googleapis.com/kubernetes-release/release/v1.24.2/bin/linux/amd64/kubectl\n\n15.28 MiB / 43.59 MiB [------------------------>____________________________________] 35.05%\n</code></pre>\n<p>It's simple, but gives enough feedback to stop you from thinking the program is stuck. In my Human Design Interaction course at university, I learned that anything over 7s triggers uncertainty in an end-user.</p>\n<p>See how it's implemented: <a href=\"https://github.com/alexellis/arkade/blob/master/pkg/get/download.go#L191\">download.go</a></p>\n<h2 id=\"http-and-rest-are-not-the-only-option\">HTTP and REST are not the only option</h2>\n<p>When I wrote <a href=\"https://github.com/alexellis/k3sup\">K3sup</a>, a tool to install K3s on remote servers, I turned to SSH to automate the process. So rather than making HTTP calls, a Go library for SSH is used to open a connection and run remote commands.</p>\n<p>It also simplifies an annoying post-installation task - managing the kubeconfig file. By default this is a protected file on the initial server you set up, k3sup will download the file and merge it with your local kubeconfig.</p>\n<pre><code>k3sup install \\\n    --host HOST1 \\\n    --user ubuntu \\\n    --merge \\\n    --local-path ~/.kube/config\n</code></pre>\n<p>I'd recommend trying out <a href=\"https://pkg.go.dev/golang.org/x/crypto/ssh\">golang.org/x/crypto/ssh</a> in your own CLIs and tools. It's great for automation, and really simple to use.</p>\n<h2 id=\"document-everything-as-best-as-you-can\">Document everything as best as you can</h2>\n<p>Here's an example of a command with good documentation:</p>\n<pre><code>Schedule additional VMs to repair the build queue.\nUse sparingly, check the build queue to see if there is a need for \nmore VMs to be launched. Then, allow ample time for the new VMs to \npick up a job by checking the build queue again for an in_progress\nstatus.\n\nUsage:\n  actuated-cli repair [flags]\n\nExamples:\n  ## Launch VMs for queued jobs in a given organisation\n  actuated repair OWNER\n\n  ## Launch VMs for queued jobs in a given organisation for a customer\n  actuated repair --staff OWNER\n\n\nFlags:\n  -h, --help    help for repair\n  -s, --staff   List staff repair\n\nGlobal Flags:\n  -t, --token string         File to read for Personal Access Token (default \"$HOME/.actuated/PAT\")\n      --token-value string   Personal Access Token\n</code></pre>\n<p>Not only does it show example usage, so users can understand <em>what can be done</em>, but it has a detailed explanation of when to use the command.</p>\n<pre><code class=\"hljs language-golang\">\tcmd := &#x26;cobra.Command{\n\t\tUse:   <span class=\"hljs-string\">\"repair\"</span>,\n\t\tShort: <span class=\"hljs-string\">\"Schedule additional VMs to repair the build queue\"</span>,\n\t\tLong: <span class=\"hljs-string\">`Schedule additional VMs to repair the build queue.\nUse sparingly, check the build queue to see if there is a need for \nmore VMs to be launched. Then, allow ample time for the new VMs to \npick up a job by checking the build queue again for an in_progress\nstatus.`</span>,\n\t\tExample: <span class=\"hljs-string\">`  ## Launch VMs for queued jobs in a given organisation\n  actuated repair OWNER\n\n  ## Launch VMs for queued jobs in a given organisation for a customer\n  actuated repair --staff OWNER\n`</span>\n    }\n</code></pre>\n<p>Browse the source code: <a href=\"https://github.com/self-actuated/actuated-cli/blob/master/cmd/repair.go\">repair.go</a></p>\n<h2 id=\"wrapping-up\">Wrapping up</h2>\n<p>I covered just a few of the recent changes - some were driven by end-user feedback, others were open source contributions, and in some cases, we just wanted to make the CLI easier to use. I've been writing CLIs for a long time, and I still have a lot to learn.</p>\n<p>What CLIs do you maintain? Could you apply any of the above to them?</p>\n<p>Do you want to learn how to master the fundamentals of Go? Check out my eBook: <a href=\"https://store.openfaas.com/l/everyday-golang\">Everyday Go</a>.</p>\n<p>If you're on a budget, I would recommend checkout out the official <a href=\"https://go.dev/tour/\">Go tour</a>, too. It'll help you understand some of the basics of the language and is a good primer for the e-book.</p>\n<p>Read the source code of the CLIs we mentioned:</p>\n<ul>\n<li><a href=\"https://github.com/self-actuated/actions-usage\">actions-usage</a> - free analytics tool for GitHub Actions</li>\n<li><a href=\"https://github.com/self-actuated/actuated-cli\">actuated-cli</a> - CLI client for actuated customers</li>\n<li><a href=\"https://github.com/openfaas/faas-cli\">faas-cli</a> - CLI client for OpenFaaS</li>\n<li><a href=\"https://github.com/alexellis/k3sup\">k3sup</a> - Install K3s over SSH</li>\n<li><a href=\"https://github.com/alexellis/arkade\">arkade</a> - Download CLI tools from GitHub releases</li>\n</ul>","title":"How to develop a great CLI with Go","description":"Alex shares his insights from building half a dozen popular Go CLIs. Which can you apply to your projects?","tags":["images","packer","qemu","kvm"],"author_img":"alex","image":"/images/2023-08-great-cli/background.png","date":"2023-08-22"}},"__N_SSG":true}