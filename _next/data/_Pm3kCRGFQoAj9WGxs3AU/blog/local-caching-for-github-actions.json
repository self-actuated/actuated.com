{"pageProps":{"post":{"slug":"local-caching-for-github-actions","fileName":"2024-02-23-local-caching-for-github-actions.md","contentHtml":"<p>We heard from the <a href=\"https://github.com/discourse/discourse\">Discourse</a> project last year because they were looking to speed up their builds. After trying out a couple of solutions that automated self-hosted runners, they found out that whilst faster CPUs were nice, reliability was a problem and the cache hosted on GitHub's network became the new bottleneck. We ran some tests to compare the hosted cache with hosted runners, to self-hosted with a local cache running with S3. This post will cover what we found.</p>\n<img src=\"/images/2024-02-local-caching-for-github-actions/discourse-readme-logo.png\" width=\"200\" alt=\"Discourse logo\">\n<blockquote>\n<p>Discourse is the online home for your community. We offer a 100% open source community platform to those who want complete control over how and where their site is run.</p>\n</blockquote>\n<h2 id=\"set-up-a-local-cache\">Set up a local cache</h2>\n<p>Hosted runners are placed close to the cache which means the latency is very low. Self-hosted runners can also make good use of this cache but the added latency can negate the advantage of switching to these faster runners. Running a local S3 cache with <a href=\"https://github.com/minio/minio\">Minio</a> or <a href=\"https://github.com/seaweedfs/seaweedfs\">Seaweedfs</a> on the self hosted runner or in the same region/network can solve this problem.</p>\n<p>For this test we ran the cache on the runner host. <a href=\"https://docs.actuated.dev/tasks/local-github-cache/\">Instructions</a> to set up a local S3 cache with Seaweedfs can be found in our docs.</p>\n<p>The Discourse repo is already using the <code>actions/cache</code>in their tests workflow which makes it easy to switch out the official <a href=\"https://github.com/actions/cache\">actions/cache</a> with <a href=\"https://github.com/tespkg/actions-cache\">tespkg/actions-cache</a>.</p>\n<p>The S3 cache is not directly compatible with the official <a href=\"https://github.com/actions/cache\">actions/cache</a> and some changes to the workflows are required to start using the cache.</p>\n<p>The <code>tespkg/actions-cache</code> supports the same properties as the actions cache and only requires some additional parameters to configure the S3 connection.</p>\n<pre><code class=\"hljs language-diff\"> - name: Bundler cache\n<span class=\"hljs-deletion\">-  uses: actions/cache@v3</span>\n<span class=\"hljs-addition\">+  uses: tespkg/actions-cache@v1</span>\n   with:\n<span class=\"hljs-addition\">+    endpoint: \"192.168.128.1\"</span>\n<span class=\"hljs-addition\">+    port: 8333</span>\n<span class=\"hljs-addition\">+    insecure: true</span>\n<span class=\"hljs-addition\">+    accessKey: ${{ secrets.ACTIONS_CACHE_ACCESS_KEY }}</span>\n<span class=\"hljs-addition\">+    secretKey: ${{ secrets.ACTIONS_CACHE_SECRET_KEY }}</span>\n<span class=\"hljs-addition\">+    bucket: actuated-runners</span>\n<span class=\"hljs-addition\">+    region: local</span>\n<span class=\"hljs-addition\">+    use-fallback: false</span>\n\n     path: vendor/bundle\n     key: ${{ runner.os }}-${{ matrix.ruby }}-gem-${{ hashFiles('**/Gemfile.lock') }}-cachev2\n</code></pre>\n<p>The endpoint could also be a HTTPS URL to a S3 server hosted within the same network as the self-hosted runners.</p>\n<p>If you are relying on the built-in cache support that is included in some actions like <a href=\"https://github.com/actions/setup-node#caching-global-packages-data\">setup-node</a> and <a href=\"https://github.com/actions/setup-go\">setup-go</a> you will need to add an additional caching step to your workflow as they are not directly compatible with the self-hosted S3 cache.</p>\n<h2 id=\"the-impact-of-switching-to-a-local-cache\">The impact of switching to a local cache</h2>\n<p>The <a href=\"https://github.com/discourse/discourse/actions/workflows/tests.yml\">Tests workflow</a> from the <a href=\"https://github.com/discourse/discourse\">Discourse repository</a> was used to test the impact of switching to a local cache. We ran the workflow on a self-hosted Actuated runner, both with the S3 local cache and with the GitHub cache.</p>\n<p>Next we looked at the time required to restore the caches in our two environments and compared it with the times we saw on GitHub hosted runners:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Bundler cache<br>(±273MB)</th>\n<th>Yarn cache<br>(±433MB)</th>\n<th>Plugins gems cache<br>(±51MB)</th>\n<th>App state cache<br>(±1MB)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Actuated with local cache</strong></td>\n<td>5s</td>\n<td>11s</td>\n<td>1s</td>\n<td>0s</td>\n</tr>\n<tr>\n<td><strong>Actuated with hosted cache</strong></td>\n<td>13s</td>\n<td>19s</td>\n<td>3s</td>\n<td>2s</td>\n</tr>\n<tr>\n<td><strong>Runner &#x26; cache hosted on GitHub</strong></td>\n<td>6s</td>\n<td>11s</td>\n<td>3s</td>\n<td>2s</td>\n</tr>\n</tbody>\n</table>\n<p>While the GitHub runner and the self-hosted runner with a local cache perform very similarly, cache restores on the self-hosted runner that uses the GitHub cache take a bit longer.</p>\n<p>If we take a look at the yarn cache, which is the biggest cache, we can see that switching to the local S3 cache saved 8s for the cache size in this test vs using GitHub's cache from a self-hosted runner. This is a 42% improvement.</p>\n<p>Depending on your workflow and the cache size this can add up quickly. If a pipeline has multiple steps or when you are running matrix builds a cache step may need to run multiple times. In the case of the Discourse repo this cache step runs nine times which adds up to 1m12s that can be saved per workflow run.</p>\n<p>When Discourse approached us, we found that they had around a dozen jobs running for each pull request, all with varying sizes of caches. At busy times of the day, their global team could have 10 or more of those pull requests running, so these savings could add up to a significant amount.</p>\n<p><strong>What if you also cached git checkout</strong></p>\n<p>If your repository is a monorepo or has lots of large artifacts, you may get a speed boost caching the <code>git checkout</code> step too. Depending on where your runners are hosted, pulling from GitHub can take some time vs. restoring the same files from a local cache.</p>\n<p>We demonstrated what impact that had for Settlemint's CTO in <a href=\"/blog/faster-self-hosted-cache\">this case study</a>. They saw a cached checkout using a GitHub's hosted cache from from 2m40s to 11s.</p>\n<p><strong>How we improved testpkg's custom action</strong></p>\n<p>During our testing we noticed that every cache restore took a minimum of 10 seconds regardless of the cache size. It turned out to be an issue with timeouts in the <code>tespkg/actions-cache</code> action when listing objects in S3. We reported it and sent them <a href=\"https://github.com/tespkg/actions-cache/pull/44\">a pull request with a fix</a>.</p>\n<p>With the fix in place restoring small caches from the local cache dropped from 10s to sub 1s.</p>\n<h2 id=\"the-impact-of-switching-to-faster-runners\">The impact of switching to faster runners</h2>\n<p>The Discourse repo uses the larger GitHub hosted runners to run tests. The jobs we are going to compare are part of the <a href=\"https://github.com/discourse/discourse/actions/workflows/tests.yml\">Tests workflow</a>. They are using runners with 8 CPUs and 32GB of ram so we replaced the <code>runs-on</code> label with an actuated label <code>actuated-8cpu-24gb</code> to run the jobs on similar sized microVMs.</p>\n<p>All jobs ran on the same <a href=\"https://www.hetzner.com/dedicated-rootserver/ax102/\">Hetzner AX102</a> bare metal host.</p>\n<p>This table compares the time it took to run each job on the hosted runner and on our Actuated runner.</p>\n<table>\n<thead>\n<tr>\n<th>Job</th>\n<th>GitHub hosted runner</th>\n<th>Actuated runner</th>\n<th>Speedup</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>core annotations</strong></td>\n<td>3m23s</td>\n<td>1m22s</td>\n<td>59%</td>\n</tr>\n<tr>\n<td><strong>core backend</strong></td>\n<td>7m11s</td>\n<td>6m0s</td>\n<td>16%</td>\n</tr>\n<tr>\n<td><strong>plugins backend</strong></td>\n<td>7m42s</td>\n<td>5m54s</td>\n<td>23%</td>\n</tr>\n<tr>\n<td><strong>plugins frontend</strong></td>\n<td>5m28s</td>\n<td>4m3s</td>\n<td>26%</td>\n</tr>\n<tr>\n<td><strong>themes frontend</strong></td>\n<td>4m20s</td>\n<td>2m46s</td>\n<td>36%</td>\n</tr>\n<tr>\n<td><strong>chat system</strong></td>\n<td>9m37s</td>\n<td>6m33s</td>\n<td>32%</td>\n</tr>\n<tr>\n<td><strong>core system</strong></td>\n<td>7m12s</td>\n<td>5m24s</td>\n<td>25%</td>\n</tr>\n<tr>\n<td><strong>plugin system</strong></td>\n<td>5m32s</td>\n<td>3m56s</td>\n<td>29%</td>\n</tr>\n<tr>\n<td><strong>themes system</strong></td>\n<td>4m32s</td>\n<td>2m41</td>\n<td>41%</td>\n</tr>\n</tbody>\n</table>\n<p>The first thing we notice is that all jobs completed faster on the Actuated runner. On average we see an improvement of around 1m40s seconds for each individual job.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>While switching to faster self-hosted runners is the most obvious way to speed up your builds, the cache hosted on GitHub's network can become a new bottleneck if you use caching in your actions. After switching to a local S3 cache we saw a very significant improvement in the cache latency. Depending on how heavily the cache is used in your workflow and the size of your cache artifacts, switching to a local S3 cache might even have a bigger impact on build times.</p>\n<p>Both Seaweedfs and Minio were tested in our setup and they performed in a very similar way. Both have different open source licenses, so we'd recommend reading those before picking one or the other. Of course you could also use AWS S3, Google Cloud Storage, or another S3 compatible hosted service.</p>\n<p>In addition to the reduced latency, switching to a self hosted cache has a couple of other benefits.</p>\n<ul>\n<li>No limit on the cache size. The GitHub cache has a size limit of 10GB before the oldest cache entries start to get pruned.</li>\n<li>No egress costs for pushing data to the cache from self-hosted runners.</li>\n</ul>\n<p>GitHub's caching action does not yet support using a custom S3 server, so we had to make some minor adjustments to the Discourse's workflow files. For this reason, if you use something like setup-go or setup-node, you won't be able to just set <code>cache: true</code>. Instead you'll need an independent caching step with the <code>testpkg/actions-cache</code> action.</p>\n<p>If you'd like to reach out to us and see if we can advise you on how to optmise your builds, you can <a href=\"https://actuated.dev/pricing\">set up a call with us here.</a>.</p>\n<p>If you want to learn more about caching for GitHub Actions checkout some of our other blog posts:</p>\n<p>You may also like:</p>\n<ul>\n<li><a href=\"https://actuated.dev/blog/caching-in-github-actions\">Make your builds run faster with Caching for GitHub Actions</a></li>\n<li><a href=\"https://actuated.dev/blog/faster-self-hosted-cache\">Fixing the cache latency for self-hosted GitHub Actions</a></li>\n<li><a href=\"https://actuated.dev/blog/is-the-self-hosted-runner-safe-github-actions\">Is GitHub's self-hosted runner safe for open source?</a></li>\n</ul>","title":"Testing the impact of a local cache for building Discourse","description":"We compare the impact of switching Discourse's GitHub Actions from self-hosted runners and a hosted cache, to a local cache with S3.","tags":["s3","githubactions","cache","latency"],"author_img":"welteki","image":"/images/2024-02-local-caching-for-github-actions/background.png","date":"2024-02-23"}},"__N_SSG":true}